<!DOCTYPE html>
<html lang="fr">
<head>
    <!-- Leaflet CSS et JS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <!-- Chart.js pour les graphiques -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- html2canvas pour capturer la carte -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <!-- Fonctions utilitaires communes -->
    <script src="utils.js"></script>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RunPacer - Votre Coach de Course</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css">
    <link rel="manifest" href="manifest.json">
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --warning-color: #e74c3c;
            --strava-color: #fc4c02;
            --dark-color: #2c3e50;
            --light-color: #ecf0f1;
            --spacing: 16px;
        }

        body.dark-mode {
            background-color: #121212;
            color: var(--light-color);
        }

        body.dark-mode nav,
        body.dark-mode .card {
            background-color: #1e1e1e;
            color: var(--light-color);
        }

        body.dark-mode nav button {
            color: var(--light-color);
        }

        body.dark-mode nav button.active {
            color: var(--secondary-color);
            border-bottom-color: var(--secondary-color);
        }

        body.dark-mode .metric-box {
            background-color: #2a2a2a;
        }

        body.dark-mode .form-control {
            background-color: #2a2a2a;
            color: var(--light-color);
            border-color: #555;
        }

        body.dark-mode table {
            color: var(--light-color);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: var(--dark-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            touch-action: manipulation;
        }
        
        header {
            background-color: var(--primary-color);
            color: white;
            padding: var(--spacing);
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: relative;
        }

        #theme-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: inherit;
            font-size: 1.2rem;
            cursor: pointer;
        }
        
        nav {
            display: flex;
            justify-content: space-around;
            background-color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        nav button {
            border: none;
            background: none;
            padding: var(--spacing);
            flex: 1;
            cursor: pointer;
            color: var(--dark-color);
            border-bottom: 3px solid transparent;
        }
        
        nav button.active {
            border-bottom: 3px solid var(--primary-color);
            color: var(--primary-color);
            font-weight: bold;
        }
        
        .container {
            flex: 1;
            padding: var(--spacing);
            max-width: 800px;
            margin: 0 auto;
            width: 100%;
        }
        
        .section {
            display: none;
            animation: fadeIn 0.3s;
        }
        
        .section.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .card {
            background-color: white;
            border-radius: 8px;
            padding: var(--spacing);
            margin-bottom: var(--spacing);
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            overflow-x: auto; /* Avoid page overflow on small screens */
        }
        
        .card-title {
            font-size: 1.2rem;
            margin-bottom: 8px;
            color: var(--primary-color);
        }
        
        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            display: inline-flex;
            align-items: center;
        }
        
        .btn i {
            margin-right: 8px;
        }
        
        .btn-lg {
            padding: 14px 20px;
            font-size: 1.1rem;
        }
        
        .btn-warning {
            background-color: var(--warning-color);
        }

        .btn-success {
            background-color: var(--secondary-color);
        }

        .btn-strava {
            background-color: var(--strava-color);
        }
        
        .run-controls {
            display: flex;
            justify-content: space-around;
            margin-top: var(--spacing);
        }
        
        .big-metric {
            font-size: 3rem;
            font-weight: bold;
            text-align: center;
            margin: 16px 0;
        }
        
        .big-metric-label {
            text-align: center;
            color: #95a5a6;
            margin-bottom: var(--spacing);
        }
        
        .metrics-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--spacing);
        }
        
        .metric-box {
            flex: 1;
            text-align: center;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            margin: 0 4px;
        }
        
        .metric-box-value {
            font-size: 1.4rem;
            font-weight: bold;
        }
        
        .metric-box-label {
            font-size: 0.8rem;
            color: #95a5a6;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--spacing);
            margin-bottom: var(--spacing);
        }
        
        .stat-item {
            background-color: white;
            padding: var(--spacing);
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .table th, .table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        .table th {
            color: var(--primary-color);
        }
        
        .too-fast {
            color: #e74c3c;
        }
        
        .good-pace {
            color: #2ecc71;
        }
        
        .too-slow {
            color: #f39c12;
        }
        
        .voice-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .hidden {
            display: none;
        }
        
        #map {
            height: 300px;
            margin-bottom: var(--spacing);
            border-radius: 8px;
            overflow: hidden;
        }
        
        #run-map {
            height: 200px;
            margin-bottom: var(--spacing);
            border-radius: 8px;
            overflow: hidden;
        }
        
        /* Formulaire profil */
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: bold;
        }
        
        .form-control {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }
        
        .form-hint {
            font-size: 0.8rem;
            color: #7f8c8d;
            margin-top: 4px;
        }
        
        /* Modal pour voir les d√©tails d'une course */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background-color: white;
            padding: var(--spacing);
            border-radius: 8px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            width: 600px;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing);
        }
        
        .modal-title {
            font-size: 1.5rem;
            color: var(--primary-color);
        }
        
        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        /* S√©lecteur de type de course */
        .run-type-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: var(--spacing);
        }
        
        .run-type {
            flex: 1;
            min-width: 120px;
        }
        
        .run-type input[type="radio"] {
            display: none;
        }
        
        .run-type label {
            display: block;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .run-type input[type="radio"]:checked + label {
            background-color: var(--primary-color);
            color: white;
        }
        
        /* Am√©lioration de l'affichage des cartes */
        .map-container {
            position: relative;
            margin-bottom: var(--spacing);
        }
        
        .map-stats {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(255,255,255,0.9);
            padding: 8px;
            border-radius: 4px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        /* Styles pour la page de d√©tail des courses */
        .map-icon {
            background: none !important;
            border: none;
        }

        .km-marker {
            background: none !important;
            border: none;
        }

        /* Animation pour les transitions de page */
        .section {
            transition: opacity 0.3s ease;
        }

        /* Styles pour le graphique d'allure */
        .pace-chart-bar {
            transition: height 0.5s ease;
        }

        /* Ensure the pace chart doesn't overflow horizontally */
        #pace-chart {
            width: 100%;
            height: auto;
        }

        /* Ensure other charts scale on small screens */
        #weekly-distance-chart,
        #speed-histogram-chart,
        #monthly-goal-chart {
            width: 100%;
            height: auto;
        }

        /* Styles pour les courses dans la liste d'historique */
        #history-table tr {
            transition: background-color 0.2s ease;
        }

        #history-table tr:hover {
            background-color: rgba(52, 152, 219, 0.1);
        }

/* Styles pour la cr√©ation de plan */
.days-selection {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 8px;
    margin-top: 8px;
}

.days-selection div {
    display: flex;
    align-items: center;
}

#plan-summary {
    margin-bottom: 16px;
    padding: 12px;
    background-color: #f8f9fa;
    border-radius: 4px;
}

#plan-summary h3 {
    color: var(--primary-color);
    margin-bottom: 8px;
}

#generated-plan-table th {
    white-space: nowrap;
}

        .selected-session {
    background-color: rgba(52, 152, 219, 0.2) !important;
    border-left: 3px solid var(--primary-color);
}

#full-plan-table tr.selected-session td {
    font-weight: bold;
}

        #full-plan-table tr:not(:first-child):hover {
    background-color: rgba(52, 152, 219, 0.1);
    transition: background-color 0.2s ease;
}
/* Calendrier d'entra√Ænement */
#plan-calendar {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 4px;
    margin-top: 8px;
}
.calendar-day {
    background-color: #f8f9fa;
    border-radius: 4px;
    padding: 2px 0;
    font-size: 0.75rem;
}
.session-icon {
    display: block;
    font-size: 1rem;
}
.session-easy { color: var(--secondary-color); }
.session-interval { color: var(--warning-color); }
.session-rest { color: #7f8c8d; }
.completed-session td {
    text-decoration: line-through;
    opacity: 0.6;
}
.calendar-day.completed {
    position: relative;
    background-color: #e9ecef;
}
.calendar-day.completed .done-star {
    position: absolute;
    top: 0;
    right: 2px;
    color: gold;
    font-size: 0.75rem;
}
.progress-container {
    margin-bottom: 8px;
}
        #goal-progress {
            width: 100%;
            height: 12px;
        }

        /* Allow horizontal scrolling for wide plan tables */
        #full-plan-container {
            overflow-x: auto;
        }

        
        /* Styles pour les statistiques d'√©l√©vation */
        .elevation-chart {
            width: 100%;
            height: 100px;
            background: linear-gradient(to bottom, #ecf0f1 0%, #ecf0f1 70%, #3498db 70%, #3498db 100%);
            position: relative;
            overflow: hidden;
            border-radius: 4px;
            margin-top: 10px;
        }

        .elevation-point {
            position: absolute;
            bottom: 0;
            width: 2px;
            background-color: rgba(52, 152, 219, 0.3);
        }

        /* Indicateur de qualit√© GPS */
        .gps-quality {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            font-size: 1.2rem;
        }

        .gps-good {
            background-color: var(--secondary-color);
            color: white;
        }

        .gps-medium {
            background-color: #f39c12;
            color: white;
        }

        .gps-poor {
            background-color: var(--warning-color);
            color: white;
        }

        /* Animation de chargement pour les cartes */
        .map-loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* Styles pour l'image du trac√© */
        .route-image {
            width: 100%;
            height: 200px;
            border-radius: 8px;
            object-fit: cover;
            margin-bottom: var(--spacing);
            border: 1px solid #eee;
        }

        /* Section d√©tails de course */
        #run-detail-section {
            display: none;
        }

        #run-detail-section.active {
            display: block;
        }

        /* √âcran d'accueil anim√© */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        #splash-screen.fade-out {
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }

        .runner-icon {
            font-size: 3rem;
            color: var(--primary-color);
            animation: runMove 2s ease-in-out forwards;
        }

        .runner-track {
            width: 120px;
            height: 4px;
            background-color: var(--light-color);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
            position: relative;
        }

        .runner-track::after {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 0;
            background-color: var(--secondary-color);
            animation: trackDraw 2s forwards;
        }

        .splash-logo {
            font-size: 2rem;
            margin-top: 20px;
            color: var(--dark-color);
        }

        @keyframes runMove {
            from { transform: translateX(-40px); }
            to { transform: translateX(40px); }
        }

        @keyframes trackDraw {
            from { width: 0; }
            to { width: 100%; }
        }

        /* Onboarding */
        #onboarding-overlay {
            position: fixed;
            inset: 0;
            background-color: white;
            z-index: 2100;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: var(--spacing);
            text-align: center;
            overflow-y: auto;
        }

        #onboarding-overlay.active {
            display: flex;
        }

        .onboarding-step { display: none; max-width: 500px; }
        .onboarding-step.active { display: block; }
        .onboarding-options { text-align: left; margin-top: 16px; }
        .onboarding-options label { display: block; margin-bottom: 8px; }
    </style>
</head>
<body>
    <div id="splash-screen">
        <i class="fas fa-running runner-icon"></i>
        <div class="runner-track"></div>
        <div class="splash-logo">RunPacer</div>
    </div>
    <div id="onboarding-overlay">
        <div class="onboarding-step" id="onboard-step-1">
            <h2>Bienvenue sur RunPacer üëã</h2>
            <p>Comment t'appelles-tu ?</p>
            <input type="text" id="onboard-name" class="form-control" placeholder="Votre pr√©nom">
            <button class="btn btn-success" id="onboard-next-1" style="margin-top:16px;">Suivant</button>
        </div>
        <div class="onboarding-step" id="onboard-step-2">
            <h2>Ton rapport avec la course</h2>
            <div class="onboarding-options">
                <label><input type="radio" name="run-habit" value="debutant" checked> üê¢ Je d√©bute, je veux commencer en douceur</label>
                <label><input type="radio" name="run-habit" value="occasionnel"> üèÉ Je cours de temps en temps</label>
                <label><input type="radio" name="run-habit" value="regulier"> üí™ Je suis un coureur r√©gulier avec des objectifs</label>
                <label><input type="radio" name="run-habit" value="course"> üéØ Je m'entra√Æne pour une course pr√©cise</label>
            </div>
            <button class="btn btn-success" id="onboard-next-2" style="margin-top:16px;">Suivant</button>
        </div>
        <div class="onboarding-step" id="onboard-step-3">
            <h2>Pourquoi RunPacer existe ? üìç</h2>
            <p>üíö RunPacer a √©t√© cr√©√© pour simplifier la course √† pied et t'accompagner dans un parcours motivant, accessible et adapt√© √† toi.</p>
            <ul style="text-align:left;">
                <li>‚úÖ Simplicit√© : pas besoin d‚Äô√™tre expert pour progresser</li>
                <li>üéØ Objectifs clairs : des plans personnalis√©s</li>
                <li>üå± Progression douce : adapt√©e √† ton niveau</li>
                <li>ü§ù Motivation : on est l√† avec toi, course apr√®s course</li>
            </ul>
            <button class="btn btn-success" id="onboard-next-3" style="margin-top:16px;">Suivant</button>
        </div>
        <div class="onboarding-step" id="onboard-step-4">
            <h2>Pr√™t √† cr√©er ton premier plan d'entra√Ænement ? üèÅ</h2>
            <button class="btn btn-success" id="onboard-create" style="margin-top:16px;">Cr√©er mon programme</button>
            <button class="btn" id="onboard-skip" style="margin-top:8px;">Je le ferai plus tard</button>
        </div>
    </div>
    <header>
        <button id="theme-toggle" title="Changer de th√®me"><i class="fas fa-moon"></i></button>
        <h1>RunPacer</h1>
        <p id="header-objective">Atteignez votre objectif de 4:00 min/km</p>
    </header>
    
    <nav>
        <button id="nav-plan" class="active"><i class="fas fa-calendar-alt"></i> Plan</button>
        <button id="nav-run"><i class="fas fa-running"></i> Courir</button>
        <button id="nav-stats" style="color: var(--primary-color);" title="Voir stats">üìä</button>
        <button id="nav-profile"><i class="fas fa-user"></i> Profil</button>
        <button id="nav-create-plan"><i class="fas fa-calendar-plus"></i> Cr√©er plan</button>
    </nav>
    
    <div class="container">
        <!-- Section Plan d'entra√Ænement -->
        <div id="plan-section" class="section active">
            <div class="card">
                <div class="card-title">Votre objectif</div>
                <p id="goal-event">Course 10km: <strong>7 juin 2025</strong></p>
                <p id="goal-pace">Objectif rythme: <strong>4:00 min/km</strong></p>
                <p id="current-level">Niveau actuel: <strong>4:36 min/km</strong></p>
                <p id="training-days">Jours d'entra√Ænement: <strong>Mardi, Jeudi, Dimanche</strong></p>
            </div>
            
            <div class="card">
                <div class="card-title">Prochaine s√©ance</div>
                <div id="next-session-details">
                    <h3 id="next-session-title">Mardi - Course facile</h3>
                    <p>Distance: <strong id="next-session-distance">5 km</strong></p>
                    <p>Rythme cible: <strong id="next-session-pace">5:00 min/km</strong></p>
                    <p id="next-session-goal">Objectif: R√©cup√©ration active, travail cardiovasculaire l√©ger</p>
                    <button class="btn btn-success" id="start-run-btn" title="D√©marrer la course"><i class="fas fa-play"></i></button>
                </div>
            </div>
            <div class="card">
                <div class="card-title">Calendrier</div>
                <div class="progress-container">
                    <progress id="goal-progress" value="0" max="100"></progress>
                    <div id="progress-text">0%</div>
                </div>
                <div id="plan-calendar"></div>
            </div>

            
            <div class="card">
                <div class="card-title">Programme complet</div>
                <div id="full-plan-container">
                    <table class="table" id="full-plan-table">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Type</th>
                                <th>Distance</th>
                                <th>Rythme</th>
                                <th>Termin√©</th>
                            </tr>
                        </thead>
                        <tbody id="full-plan-body">
                            <!-- Le plan complet sera g√©n√©r√© ici -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <!-- Section Course active -->
        <div id="run-section" class="section">
            <div class="card">
                <div class="card-title">Type de course</div>
                <div class="run-type-selector" id="run-type-selector">
                    <div class="run-type">
                        <input type="radio" id="easy-run" name="run-type" value="easy" checked>
                        <label for="easy-run"><i class="fas fa-walking"></i> Course facile</label>
                    </div>
                    <div class="run-type">
                        <input type="radio" id="interval-run" name="run-type" value="interval">
                        <label for="interval-run"><i class="fas fa-tachometer-alt"></i> Intervalles</label>
                    </div>
                    <div class="run-type">
                        <input type="radio" id="long-run" name="run-type" value="long">
                        <label for="long-run"><i class="fas fa-road"></i> Longue sortie</label>
                    </div>
                    <div class="run-type">
                        <input type="radio" id="tempo-run" name="run-type" value="tempo">
                        <label for="tempo-run"><i class="fas fa-fire"></i> Course tempo</label>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <div class="big-metric-label">Rythme actuel</div>
                <div class="big-metric" id="current-pace">--:--</div>
                <div id="pace-feedback" class="good-pace">Pr√™t √† commencer</div>
            </div>

            <div id="interval-indicator" class="hidden" style="text-align: center; margin: 10px 0; font-weight: bold;">
    <span id="interval-phase">Intervalle rapide</span>
    <span id="interval-distance" style="display: block; font-size: 0.8em;"></span>
</div>
            
            <div class="metrics-row">
                <div class="metric-box">
                    <div class="metric-box-value" id="distance">0.00</div>
                    <div class="metric-box-label">KM</div>
                </div>
                <div class="metric-box">
                    <div class="metric-box-value" id="duration">00:00</div>
                    <div class="metric-box-label">TEMPS</div>
                </div>
                <div class="metric-box">
                    <div class="metric-box-value" id="target-pace">--:--</div>
                    <div class="metric-box-label">OBJECTIF</div>
                </div>
            </div>
            
            <div id="map">
                <!-- La carte sera charg√©e ici -->
            </div>
            
            <div class="run-controls">
                <button class="btn btn-lg btn-success" id="pause-btn" title="D√©marrer la course"><i class="fas fa-play"></i></button>
                <button class="btn btn-lg btn-warning" id="stop-btn" disabled><i class="fas fa-stop"></i></button>
            </div>
            
            <div class="voice-indicator hidden" id="voice-indicator">
                <i class="fas fa-volume-up"></i>
            </div>
        </div>
        
        <!-- Section Statistiques -->
        <div id="stats-section" class="section">
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="total-runs">0</div>
                    <div>Courses effectu√©es</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="best-pace">--:--</div>
                    <div>Meilleur rythme</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="total-distance">0</div>
                    <div>Distance totale (km)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="avg-pace">--:--</div>
                    <div>Rythme moyen</div>
                </div>
            </div>
            
            <div class="card">
                <div class="card-title">Progression du rythme</div>
                <canvas id="pace-chart" width="400" height="200"></canvas>
            </div>

            <div class="card">
                <div class="card-title">Distances hebdomadaires</div>
                <canvas id="weekly-distance-chart" width="400" height="200"></canvas>
            </div>

            <div class="card">
                <div class="card-title">Histogramme des vitesses</div>
                <canvas id="speed-histogram-chart" width="400" height="200"></canvas>
            </div>

            <div class="card">
                <div class="card-title">Objectif mensuel</div>
                <canvas id="monthly-goal-chart" width="200" height="200"></canvas>
            </div>

            <div class="card">
                <div class="card-title">Historique des courses</div>
                <table class="table">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Type</th>
                            <th>Distance</th>
                            <th>Rythme</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="history-table">
                        <!-- L'historique sera rempli dynamiquement -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- Section Profil -->
        <div id="profile-section" class="section">
            <div class="card">
                <div class="card-title">Mes informations</div>
                <form id="profile-form">
                    <div class="form-group">
                        <label for="current-pace-input">Rythme actuel</label>
                        <input type="text" class="form-control" id="current-pace-input" value="4:36" placeholder="min:sec">
                        <div class="form-hint">Votre rythme actuel sur 10km</div>
                    </div>
                    
                    <div class="form-group">
                        <label for="target-pace-input">Rythme objectif</label>
                        <input type="text" class="form-control" id="target-pace-input" value="4:00" placeholder="min:sec">
                        <div class="form-hint">Votre objectif de rythme pour votre prochaine course</div>
                    </div>
                    
                    <div class="form-group">
                        <label for="event-date-input">Date de l'√©v√©nement</label>
                        <input type="date" class="form-control" id="event-date-input" value="2025-06-07">
                    </div>
                    
                    <div class="form-group">
                        <label>Jours d'entra√Ænement pr√©f√©r√©s</label>
                        <div>
                            <input type="checkbox" id="monday" name="training-days">
                            <label for="monday">Lundi</label>
                        </div>
                        <div>
                            <input type="checkbox" id="tuesday" name="training-days" checked>
                            <label for="tuesday">Mardi</label>
                        </div>
                        <div>
                            <input type="checkbox" id="wednesday" name="training-days">
                            <label for="wednesday">Mercredi</label>
                        </div>
                        <div>
                            <input type="checkbox" id="thursday" name="training-days" checked>
                            <label for="thursday">Jeudi</label>
                        </div>
                        <div>
                            <input type="checkbox" id="friday" name="training-days">
                            <label for="friday">Vendredi</label>
                        </div>
                        <div>
                            <input type="checkbox" id="saturday" name="training-days">
                            <label for="saturday">Samedi</label>
                        </div>
                        <div>
                            <input type="checkbox" id="sunday" name="training-days" checked>
                            <label for="sunday">Dimanche</label>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="voice-enabled">Instructions vocales</label>
                        <div>
                            <input type="checkbox" id="voice-enabled" checked>
                            <label for="voice-enabled">Activer les instructions vocales</label>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="strava-token-input">Token d'acc√®s Strava</label>
                        <input type="text" class="form-control" id="strava-token-input" placeholder="OAuth token">
                        <div class="form-hint">G√©n√©rez un token depuis votre compte Strava</div>
                    </div>

                    <div class="form-group">
                        <button type="button" class="btn btn-strava" id="strava-connect-btn" title="Connecter Strava"><i class="fas fa-link"></i></button>
                        <div id="strava-status" class="form-hint"></div>
                    </div>
                    
                    <button type="submit" class="btn btn-success">Enregistrer les modifications</button>
                </form>
            </div>
        </div>

        <!-- Section Cr√©ation de plan -->
<div id="create-plan-section" class="section">
    <div class="card">
        <div class="card-title">Cr√©er un plan d'entra√Ænement</div>
        <form id="plan-form">
            <div class="form-group">
                <label for="plan-distance">Distance de course cible</label>
                <select class="form-control" id="plan-distance">
                    <option value="5">5 km</option>
                    <option value="10" selected>10 km</option>
                    <option value="21.1">Semi-marathon (21.1 km)</option>
                    <option value="42.2">Marathon (42.2 km)</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="plan-event-date">Date de la course</label>
                <input type="date" class="form-control" id="plan-event-date" min="">
            </div>
            
            <div class="form-group">
                <label for="plan-current-time">Votre temps actuel pour 10 km (hh:mm:ss)</label>
                <input type="text" class="form-control" id="plan-current-time" placeholder="00:50:00">
            </div>
            
            <div class="form-group">
                <label for="plan-target-time">Temps objectif pour 10 km (hh:mm:ss)</label>
                <input type="text" class="form-control" id="plan-target-time" placeholder="00:45:00">
            </div>
            
            <div class="form-group">
                <label for="plan-sessions">Nombre de s√©ances par semaine</label>
                <select class="form-control" id="plan-sessions">
                    <option value="3">3 s√©ances</option>
                    <option value="4" selected>4 s√©ances</option>
                    <option value="5">5 s√©ances</option>
                </select>
            </div>
            
            <div class="form-group">
                <label>Jours d'entra√Ænement pr√©f√©r√©s</label>
                <div class="days-selection">
                    <input type="checkbox" id="plan-monday" name="plan-training-days">
                    <label for="plan-monday">Lundi</label>
                    
                    <input type="checkbox" id="plan-tuesday" name="plan-training-days" checked>
                    <label for="plan-tuesday">Mardi</label>
                    
                    <input type="checkbox" id="plan-wednesday" name="plan-training-days">
                    <label for="plan-wednesday">Mercredi</label>
                    
                    <input type="checkbox" id="plan-thursday" name="plan-training-days" checked>
                    <label for="plan-thursday">Jeudi</label>
                    
                    <input type="checkbox" id="plan-friday" name="plan-training-days">
                    <label for="plan-friday">Vendredi</label>
                    
                    <input type="checkbox" id="plan-saturday" name="plan-training-days">
                    <label for="plan-saturday">Samedi</label>
                    
                    <input type="checkbox" id="plan-sunday" name="plan-training-days" checked>
                    <label for="plan-sunday">Dimanche</label>
                </div>
            </div>
            
            <button type="submit" class="btn btn-success">G√©n√©rer le plan</button>
        </form>
    </div>
    
    <div class="card" id="generated-plan-card" style="display: none;">
        <div class="card-title">Plan g√©n√©r√©</div>
        <div id="plan-summary"></div>
        <table class="table" id="generated-plan-table">
            <thead>
                <tr>
                    <th>Semaine</th>
                    <th>Date</th>
                    <th>Type</th>
                    <th>Distance</th>
                    <th>Rythme</th>
                    <th>Objectif</th>
                </tr>
            </thead>
            <tbody id="generated-plan-body">
                <!-- Le plan g√©n√©r√© sera affich√© ici -->
            </tbody>
        </table>
        <button class="btn" id="save-plan-btn"><i class="fas fa-save"></i> Sauvegarder ce plan</button>
    </div>
</div>
        
        <!-- Section D√©tails de course -->
        <div id="run-detail-section" class="section">
            <div class="card">
                <div class="card-title">D√©tails de la course</div>
                <div class="big-metric-label" id="run-date">12 avril 2025</div>
                <div class="metrics-row">
                    <div class="metric-box">
                        <div class="metric-box-value" id="run-detail-distance">5.2</div>
                        <div class="metric-box-label">KM</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-box-value" id="run-detail-duration">25:12</div>
                        <div class="metric-box-label">TEMPS</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-box-value" id="run-detail-pace">4:50</div>
                        <div class="metric-box-label">RYTHME</div>
                    </div>
                </div>
                
                <!-- Image du trac√© de la course -->
                <div class="card-title">Trac√© de votre course</div>
                <img id="route-image" class="route-image" src="" alt="Trac√© de la course">
                
                <div class="metrics-row">
                    <div class="metric-box">
                        <div class="metric-box-value" id="run-detail-elevation">42</div>
                        <div class="metric-box-label">D+ (m)</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-box-value" id="run-detail-best-pace">4:20</div>
                        <div class="metric-box-label">MEILLEUR KM</div>
                    </div>
                </div>
                
                <div class="card-title">D√©tails par kilom√®tre</div>
                <table class="table">
                    <thead>
                        <tr>
                            <th>KM</th>
                            <th>Temps</th>
                            <th>Rythme</th>
                        </tr>
                    </thead>
                    <tbody id="run-splits">
                        <!-- Les splits seront ajout√©s ici -->
                    </tbody>
                </table>
            </div>
            
            <div class="run-controls">
                <button class="btn" id="share-run-btn"><i class="fas fa-share-alt"></i> Partager</button>
                <button class="btn" id="export-gpx-btn"><i class="fas fa-file-export"></i> Exporter GPX</button>
                <button class="btn" id="strava-upload-btn"><i class="fab fa-strava"></i> Strava</button>
                <button class="btn" id="back-to-stats-btn"><i class="fas fa-arrow-left"></i> Retour</button>
            </div>
        </div>
    </div>

    <!-- Modal pour voir les d√©tails d'une course -->
    <div class="modal" id="run-details-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="modal-run-title">D√©tails de la course</h3>
                <button class="close-modal">&times;</button>
            </div>
            <div id="modal-run-content">
                <div class="map-container">
                    <div id="run-map"></div>
                    <div class="map-stats">
                        <div>Distance: <strong id="modal-distance">0.00 km</strong></div>
                        <div>Dur√©e: <strong id="modal-duration">00:00</strong></div>
                        <div>Rythme: <strong id="modal-pace">--:-- min/km</strong></div>
                    </div>
                </div>
                
                <div class="metrics-row">
                    <div class="metric-box">
                        <div class="metric-box-value" id="modal-avg-pace">--:--</div>
                        <div class="metric-box-label">RYTHME MOYEN</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-box-value" id="modal-max-pace">--:--</div>
                        <div class="metric-box-label">MAX</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-box-value" id="modal-min-pace">--:--</div>
                        <div class="metric-box-label">MIN</div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-title">D√©tails par kilom√®tre</div>
                    <table class="table">
                        <thead>
                            <tr>
                                <th>KM</th>
                                <th>Temps</th>
                                <th>Rythme</th>
                            </tr>
                        </thead>
                        <tbody id="modal-splits">
                            <!-- Les splits seront ajout√©s ici -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration initiale
        const STRAVA_CLIENT_ID = '169011';
        const STRAVA_CLIENT_SECRET = '6e9f34aa96365b1daf849922ba15c9d003af824b';
        const STRAVA_REDIRECT_URI = window.location.origin + window.location.pathname;
        const MONTHLY_GOAL_KM = 100; // objectif mensuel par d√©faut
        const userData = {
    firstName: '',
    currentPace: "4:36", // minutes:secondes par km
    targetPace: "4:00",
    eventDate: "2025-06-07",
    trainingDays: ["tuesday", "thursday", "sunday"],
    voiceEnabled: true,
    stravaToken: "",
    stravaRefreshToken: "",
    stravaExpiresAt: 0,
    runs: [], // Historique des courses
    trainingPlan: [], // Plan d'entra√Ænement g√©n√©r√©
    customPlan: null // Stockera le plan personnalis√© g√©n√©r√©
    ,theme: 'light'
};

        // Variables pour le suivi en arri√®re-plan
let isBackgroundRun = false;
let backgroundRunInterval;
        
        // Variables pour le suivi de course
        let isRunning = false;
        let runInterval;
        let currentDuration = 0;
        let distanceTraveled = 0;
        let locationData = [];
        let previousLocation = null;
        let watchId;
        let isTrackingLocation = false;
        let mapObject;
        let runMapObject;
        let lastSpokenTime = 0;
        let currentRunType = "easy";
        let kmSplits = [];
let currentKmStartTime = 0;
let currentKmStartDistance = 0;
let currentRouteImage = null;
let runStartTime = null; // ISO string du d√©but de la course
let runStartTimestamp = 0; // Timestamp en ms pour la persistance
// Ajouter ces variables en haut avec les autres :
let intervalPhase = 'work'; // 'work' ou 'recovery'
let intervalDistanceRemaining = 0;
let currentTargetPace = "5:00"; // Valeur par d√©faut

const slowPhrases = ["Allez, on acc√©l√®re !","Tu peux le faire, garde le rythme !","Courage, pousse un peu plus !","Ne l√¢che rien, continue !","Encore un effort, tu y es presque !"];

function applyTheme(theme) {
    document.body.classList.toggle('dark-mode', theme === 'dark');
    const toggle = document.getElementById('theme-toggle');
    if (toggle) {
        toggle.innerHTML = theme === 'dark' ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
    }
}
        
       
const runTypes = {
    easy: {
        name: "Course facile",
        description: "R√©cup√©ration active, travail cardiovasculaire l√©ger",
        paceOffset: 1.0, // +1 min/km par rapport au rythme actuel
        distance: 5,
        isInterval: false
    },
    interval: {
        name: "Intervalles",
        description: "Alternance de courses rapides et de r√©cup√©ration",
        paceOffset: -0.25, // -15 sec/km pour les portions rapides
        recoveryPaceOffset: 1.5, // +1:30 min/km pour la r√©cup√©ration
        distance: 6,
        intervalDuration: 400, // dur√©e de chaque intervalle en m√®tres
        recoveryDuration: 200, // dur√©e de r√©cup√©ration en m√®tres
        isInterval: true
    },
    long: {
        name: "Longue sortie",
        description: "D√©veloppement de l'endurance fondamentale",
        paceOffset: 0.75, // +45 sec/km par rapport au rythme actuel
        distance: 8,
        isInterval: false
    },
    tempo: {
        name: "Course tempo",
        description: "Allure soutenue proche du seuil ana√©robie",
        paceOffset: -0.5, // -30 sec/km par rapport au rythme actuel
        distance: 5,
        isInterval: false
    }
};
        
        // Conversion de pace (min:sec) en secondes
        function paceToSeconds(pace) {
            const parts = pace.split(':');
            return parseInt(parts[0]) * 60 + parseInt(parts[1]);
        }
        
        // Conversion de secondes en pace (min:sec)
        function secondsToPace(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Convertir un rythme "mm:ss" en texte lisible pour la synth√®se vocale
        function paceToSpeech(pace) {
            const [mins, secs] = pace.split(':').map(Number);
            const minuteWord = mins > 1 ? 'minutes' : 'minute';
            let result = `${mins} ${minuteWord}`;
            if (secs > 0) {
                result += ` ${secs}`;
            }
            return result;
        }

        // Faire vibrer l'appareil si possible
        function vibratePhone() {
            if (navigator.vibrate) {
                navigator.vibrate([200, 100, 200]);
            }
        }

        // Annoncer la phase d'intervalle avec rythme et distance
        function announceInterval(phase) {
            if (!userData.voiceEnabled) return;
            const distance = phase === 'work'
                ? runTypes[currentRunType].intervalDuration
                : runTypes[currentRunType].recoveryDuration;
            const paceSpeech = paceToSpeech(currentTargetPace);
            const label = phase === 'work' ? 'Intervalle rapide' : 'R√©cup√©ration';
            const utterance = new SpeechSynthesisUtterance(`${label}. Courez √† ${paceSpeech} par kilom√®tre pendant ${distance} m√®tres.`);
            utterance.lang = 'fr-FR';
            speechSynthesis.speak(utterance);

            document.getElementById('voice-indicator').classList.remove('hidden');
            setTimeout(() => {
                document.getElementById('voice-indicator').classList.add('hidden');
            }, 3000);
        }

        // Mettre √† jour l'indicateur d'intervalle √† l'√©cran
        function updateIntervalIndicator() {
            if (runTypes[currentRunType].isInterval) {
                document.getElementById('interval-indicator').classList.remove('hidden');
                document.getElementById('interval-phase').textContent =
                    intervalPhase === 'work' ? 'Intervalle rapide' : 'R√©cup√©ration';
                document.getElementById('interval-distance').textContent =
                    `Distance restante: ${Math.round(intervalDistanceRemaining)} m`;
            } else {
                document.getElementById('interval-indicator').classList.add('hidden');
            }
        }

        // Formater le temps en hh:mm:ss
        function formatTime(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            if (hours > 0) {
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else {
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }
        
    

// Fonction pour g√©n√©rer un plan personnalis√©
function generateCustomPlan() {
    // R√©cup√©rer les valeurs du formulaire
    const distance = parseFloat(document.getElementById('plan-distance').value);
    const eventDate = new Date(document.getElementById('plan-event-date').value);
    const currentTime = document.getElementById('plan-current-time').value;
    const targetTime = document.getElementById('plan-target-time').value;
    const sessionsPerWeek = parseInt(document.getElementById('plan-sessions').value);
    
    // R√©cup√©rer les jours s√©lectionn√©s
    const selectedDays = [];
    const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
    days.forEach(day => {
        if (document.getElementById(`plan-${day}`).checked) {
            selectedDays.push(day);
        }
    });
    
    // Validation des entr√©es
    if (!eventDate || isNaN(eventDate.getTime())) {
        alert("Veuillez s√©lectionner une date valide");
        return;
    }
    
    if (!isValidTimeFormat(currentTime) || !isValidTimeFormat(targetTime)) {
        alert("Veuillez entrer des temps valides au format hh:mm:ss");
        return;
    }
    
    if (selectedDays.length === 0) {
        alert("Veuillez s√©lectionner au moins un jour d'entra√Ænement");
        return;
    }
    
    if (selectedDays.length < sessionsPerWeek) {
        alert(`Vous avez s√©lectionn√© ${selectedDays.length} jours mais demand√© ${sessionsPerWeek} s√©ances par semaine.`);
        return;
    }
    
    // Convertir les temps en secondes
    const currentTimeSec = timeToSeconds(currentTime);
    const targetTimeSec = timeToSeconds(targetTime);
    
    // Calculer les rythmes actuels et cibles (en secondes/km)
    const currentPaceSec = currentTimeSec / 10; // pour 10km
    const targetPaceSec = targetTimeSec / 10; // pour 10km
    
    // Calculer la dur√©e totale du plan en semaines
    const today = new Date();
    const weeksDiff = Math.ceil((eventDate - today) / (1000 * 60 * 60 * 24 * 7));
    
    if (weeksDiff <= 0) {
        alert("La date de la course doit √™tre dans le futur");
        return;
    }
    
    // Cr√©er le plan
    const plan = [];
    const progressPerWeek = (targetPaceSec - currentPaceSec) / weeksDiff;
    
    // G√©n√©rer les semaines d'entra√Ænement
    for (let week = 1; week <= weeksDiff; week++) {
        const weekStartDate = new Date(today);
        weekStartDate.setDate(today.getDate() + ((week - 1) * 7));
        
        // Calculer le rythme cible pour cette semaine
        const weekTargetPaceSec = currentPaceSec + (progressPerWeek * (week - 1));
        
        // S√©lectionner al√©atoirement les jours d'entra√Ænement pour cette semaine
        const shuffledDays = [...selectedDays].sort(() => 0.5 - Math.random());
        const weekDays = shuffledDays.slice(0, sessionsPerWeek).sort();
        
        // G√©n√©rer les s√©ances pour chaque jour s√©lectionn√©
        weekDays.forEach(day => {
            const dayIndex = days.indexOf(day);
            const sessionDate = new Date(weekStartDate);
            sessionDate.setDate(weekStartDate.getDate() + dayIndex);
            
            // D√©terminer le type de s√©ance
            let type, sessionDistance, sessionPaceSec;
            
            // En fonction de la semaine et du jour
            if (week === weeksDiff) {
                // Semaine de la course - s√©ance l√©g√®re
                type = 'easy';
                sessionDistance = distance * 0.5;
                sessionPaceSec = weekTargetPaceSec + 60; // +1 min/km
            } else if (day === 'tuesday' || day === 'wednesday' || day === 'thursday') {
                // Jour de semaine - s√©ance de qualit√©
                type = Math.random() > 0.5 ? 'interval' : 'tempo';
                
                if (type === 'interval') {
                    sessionDistance = 6 + (week * 0.2); // Augmente l√©g√®rement chaque semaine
                    sessionPaceSec = weekTargetPaceSec - (15 * (week / weeksDiff)); // Plus rapide que la cible
                } else {
                    sessionDistance = 5 + (week * 0.1);
                    sessionPaceSec = weekTargetPaceSec - (30 * (week / weeksDiff));
                }
            } else {
                // Week-end - longue sortie ou course facile
                if (day === 'saturday' || day === 'sunday') {
                    type = 'long';
                    sessionDistance = 8 + (week * 0.5); // Augmente progressivement
                    sessionPaceSec = weekTargetPaceSec + 45; // +45 sec/km
                } else {
                    type = 'easy';
                    sessionDistance = 5 + (week * 0.1);
                    sessionPaceSec = weekTargetPaceSec + 60; // +1 min/km
                }
            }
            
            // Ajuster pour la distance cible
            if (distance === 5) {
                sessionDistance = Math.min(sessionDistance, 5);
            } else if (distance === 21.1) {
                // Pour semi-marathon
                if (type === 'long') {
                    sessionDistance = Math.min(8 + (week * 1.5), 18);
                }
            } else if (distance === 42.2) {
                // Pour marathon
                if (type === 'long') {
                    sessionDistance = Math.min(10 + (week * 2), 32);
                }
            }
            
            // Arrondir les valeurs
            sessionDistance = Math.round(sessionDistance * 2) / 2; // Arrondir au 0.5 km pr√®s
            
            // Ajouter la s√©ance au plan
            plan.push({
                week: week,
                date: sessionDate.toISOString().split('T')[0],
                day: day,
                type: type,
                typeName: runTypes[type].name,
                distance: sessionDistance,
                pace: secondsToPace(sessionPaceSec),
                goal: runTypes[type].description,
                completed: false
            });
        });
    }
    
    // Afficher le plan g√©n√©r√©
    displayGeneratedPlan(plan, distance, eventDate, currentTime, targetTime);
}

// Afficher le plan g√©n√©r√©
function displayGeneratedPlan(plan, distance, eventDate, currentTime, targetTime) {
    const tbody = document.getElementById('generated-plan-body');
    tbody.innerHTML = '';
    
    let currentWeek = 0;
    
    plan.forEach(session => {
        if (session.week !== currentWeek) {
            // Ajouter une ligne de s√©paration pour la nouvelle semaine
            const weekRow = document.createElement('tr');
            weekRow.className = 'week-separator';
            weekRow.innerHTML = `<td colspan="6" style="background-color: #f8f9fa; font-weight: bold;">Semaine ${session.week}</td>`;
            tbody.appendChild(weekRow);
            currentWeek = session.week;
        }
        
        const tr = document.createElement('tr');
        const date = new Date(session.date);
        const formattedDate = date.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' });
        
        tr.innerHTML = `
            <td>${session.week}</td>
            <td>${formattedDate} (${session.day.charAt(0).toUpperCase() + session.day.slice(1)})</td>
            <td>${session.typeName}</td>
            <td>${session.distance} km</td>
            <td>${session.pace} min/km</td>
            <td>${session.goal}</td>
        `;
        
        tbody.appendChild(tr);
    });
    
    // Mettre √† jour le r√©sum√©
    const formattedEventDate = eventDate.toLocaleDateString('fr-FR', { day: 'numeric', month: 'long', year: 'numeric' });
    document.getElementById('plan-summary').innerHTML = `
        <h3>R√©sum√© du plan</h3>
        <p><strong>Course cible:</strong> ${distance} km le ${formattedEventDate}</p>
        <p><strong>Progression:</strong> De ${currentTime} √† ${targetTime} pour 10 km</p>
        <p><strong>Dur√©e:</strong> ${plan[plan.length - 1].week} semaines</p>
        <p><strong>S√©ances totales:</strong> ${plan.length}</p>
    `;
    
    // Afficher la section du plan g√©n√©r√©
    document.getElementById('generated-plan-card').style.display = 'block';
    
    // Sauvegarder le plan g√©n√©r√© temporairement
    userData.customPlan = plan;
}

// Valider le format de temps hh:mm:ss
function isValidTimeFormat(time) {
    return /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/.test(time);
}

// Convertir un temps hh:mm:ss en secondes
function timeToSeconds(time) {
    const parts = time.split(':').map(Number);
    return parts[0] * 3600 + parts[1] * 60 + parts[2];
}

// Sauvegarder le plan g√©n√©r√©
document.getElementById('save-plan-btn').addEventListener('click', function() {
    if (!userData.customPlan) {
        alert("Aucun plan √† sauvegarder");
        return;
    }
    
    // Mettre √† jour le plan d'entra√Ænement
    userData.trainingPlan = userData.customPlan;
    
    // Mettre √† jour les autres donn√©es utilisateur
    userData.targetPace = secondsToPace(timeToSeconds(document.getElementById('plan-target-time').value) / 10);
    userData.currentPace = secondsToPace(timeToSeconds(document.getElementById('plan-current-time').value) / 10);
    userData.eventDate = document.getElementById('plan-event-date').value;
    
    // Mettre √† jour les jours d'entra√Ænement
    userData.trainingDays = [];
    const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
    days.forEach(day => {
        if (document.getElementById(`plan-${day}`).checked) {
            userData.trainingDays.push(day);
        }
    });
    
    // Sauvegarder dans le stockage local
    localStorage.setItem('runPacerUserData', JSON.stringify(userData));
    
    // Mettre √† jour l'affichage
    updateProfileDisplay();
    updateTrainingPlanDisplay();
    
    // Retourner √† la section plan
    sections.forEach(s => {
        document.getElementById(`nav-${s}`).classList.remove('active');
        document.getElementById(`${s}-section`).classList.remove('active');
    });
    
    document.getElementById('nav-plan').classList.add('active');
    document.getElementById('plan-section').classList.add('active');
    
    alert("Votre plan a √©t√© sauvegard√© avec succ√®s!");
});

// Gestion du formulaire de cr√©ation de plan
document.getElementById('plan-form').addEventListener('submit', function(e) {
    e.preventDefault();
    generateCustomPlan();
});

// Initialiser la date minimale (aujourd'hui + 1 jour)
document.getElementById('plan-event-date').min = new Date(new Date().getTime() + 86400000).toISOString().split('T')[0];
        
        // G√©n√©rer un plan d'entra√Ænement jusqu'√† la date de l'√©v√©nement
        function generateTrainingPlan() {
            const eventDate = new Date(userData.eventDate);
            const today = new Date();
            const daysDiff = Math.floor((eventDate - today) / (1000 * 60 * 60 * 24));
            
            if (daysDiff <= 0) {
                userData.trainingPlan = [];
                return;
            }
            
            const currentPaceSeconds = paceToSeconds(userData.currentPace);
            const targetPaceSeconds = paceToSeconds(userData.targetPace);
            const progressPerWeek = (targetPaceSeconds - currentPaceSeconds) / (daysDiff / 7);
            
            const plan = [];
            const trainingDays = userData.trainingDays;
            
            // G√©n√©rer les s√©ances pour chaque semaine
            for (let i = 0; i < daysDiff; i++) {
                const date = new Date(today);
                date.setDate(today.getDate() + i);
                const dayName = date.toLocaleDateString('fr-FR', { weekday: 'long' }).toLowerCase();
                
                if (trainingDays.includes(dayName)) {
                    // D√©terminer le type de s√©ance en fonction du jour
                    let type, distance, pace;
                    
                    if (dayName === 'mardi' || dayName === 'jeudi') {
                        // S√©ance de qualit√© (intervalles ou tempo)
                        type = Math.random() > 0.5 ? 'interval' : 'tempo';
                    } else {
                        // S√©ance longue ou facile
                        type = Math.random() > 0.5 ? 'long' : 'easy';
                    }
                    
                    // Calculer la distance et le rythme en fonction de la progression
                    const weekNum = Math.floor(i / 7);
                    const currentWeekPace = currentPaceSeconds + (progressPerWeek * weekNum);
                    const runType = runTypes[type];
                    
                    distance = runType.distance;
                    pace = secondsToPace(currentWeekPace + (runType.paceOffset * 60));
                    
                    // Ajouter la s√©ance au plan
                    plan.push({
                        date: date.toISOString().split('T')[0],
                        day: dayName,
                        type: type,
                        typeName: runType.name,
                        distance: distance,
                        pace: pace,
                        completed: false
                    });
                }
            }
            
            userData.trainingPlan = plan;
            updateTrainingPlanDisplay();
            saveTrainingPlan();
        }
        
        // Mettre √† jour l'affichage du plan d'entra√Ænement
        function updateTrainingPlanDisplay() {
    const tbody = document.getElementById('full-plan-body');
    tbody.innerHTML = '';
    
    userData.trainingPlan.forEach((session, index) => {
        const tr = document.createElement('tr');
        tr.style.cursor = 'pointer';
        tr.addEventListener('click', () => startSelectedSession(index));
        if (session.completed) {
            tr.classList.add('completed-session');
        }
        
        const date = new Date(session.date);
        const formattedDate = date.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' });
        
        tr.innerHTML = `
            <td>${formattedDate} (${session.day.charAt(0).toUpperCase() + session.day.slice(1)})</td>
            <td>${session.typeName}</td>
            <td>${session.distance} km</td>
            <td>${session.pace} min/km</td>
            <td>${session.completed ? '<i class="fas fa-check" style="color: #2ecc71;"></i>' : '<i class="fas fa-times" style="color: #e74c3c;"></i>'}</td>
        `;
        
        tbody.appendChild(tr);
    });
    
    updateNextSession();
    renderTrainingCalendar();
    updateGoalProgress();
}


function startSelectedSession(sessionIndex) {
    const session = userData.trainingPlan[sessionIndex];

    if (!session) return;

    if (session.completed) {
        const runIndex = userData.runs.findIndex(r => r.date === session.date && r.type === session.type);
        if (runIndex !== -1) {
            showRunDetails(runIndex);
            return;
        }
    }

    const confirmMsg = `D\u00e9marrer la s\u00e9ance du ${new Date(session.date).toLocaleDateString('fr-FR')} ?`;
    if (!confirm(confirmMsg)) {
        return;
    }

    // Retirer la s√©lection pr√©c√©dente
    document.querySelectorAll('#full-plan-table tr').forEach(tr => {
        tr.classList.remove('selected-session');
    });
    
    // Ajouter la s√©lection √† la ligne cliqu√©e
    const allRows = document.querySelectorAll('#full-plan-table tr');
    if (allRows.length > sessionIndex + 1) { // +1 pour l'en-t√™te
        allRows[sessionIndex + 1].classList.add('selected-session');
    }
                
    // D√©sactiver toutes les sections
    sections.forEach(s => {
        document.getElementById(`nav-${s}`).classList.remove('active');
        document.getElementById(`${s}-section`).classList.remove('active');
    });
    
    // Activer la section "Courir"
    document.getElementById('nav-run').classList.add('active');
    document.getElementById('run-section').classList.add('active');
    
    // D√©finir le type de course s√©lectionn√©
    currentRunType = session.type;
    document.getElementById(`${session.type}-run`).checked = true;
    
    // Mettre √† jour l'affichage du rythme cible
    document.getElementById('target-pace').textContent = session.pace;
    
    // D√©marrer la course
    startRun();
}
        
        // Mettre √† jour l'affichage de la prochaine s√©ance
        function updateNextSession() {
            const nextSession = userData.trainingPlan.find(session => !session.completed);
            
            if (nextSession) {
                const date = new Date(nextSession.date);
                const formattedDate = date.toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' });
                
                document.getElementById('next-session-title').textContent = `${formattedDate.charAt(0).toUpperCase() + formattedDate.slice(1)} - ${nextSession.typeName}`;
                document.getElementById('next-session-distance').textContent = `${nextSession.distance} km`;
                document.getElementById('next-session-pace').textContent = `${nextSession.pace} min/km`;
                document.getElementById('next-session-goal').textContent = runTypes[nextSession.type].description;
                
                // Mettre √† jour le type de course par d√©faut
                currentRunType = nextSession.type;
                document.getElementById(`${nextSession.type}-run`).checked = true;
            } else {
                document.getElementById('next-session-title').textContent = "Aucune s√©ance programm√©e";
                document.getElementById('next-session-distance').textContent = "-- km";
                document.getElementById('next-session-pace').textContent = "--:-- min/km";
                document.getElementById('next-session-goal').textContent = "Votre plan d'entra√Ænement est termin√©!";
            }
        }
        
function renderTrainingCalendar() {
    const cal = document.getElementById('plan-calendar');
    if (!cal) return;
    cal.innerHTML = '';
    if (userData.trainingPlan.length === 0) return;
    const days = ['Lu','Ma','Me','Je','Ve','Sa','Di'];
    days.forEach(d => {
        const head = document.createElement('div');
        head.className = 'calendar-day';
        head.style.fontWeight = 'bold';
        head.textContent = d;
        cal.appendChild(head);
    });
    const start = new Date(userData.trainingPlan[0].date);
    const end = new Date(userData.eventDate);
    const offset = (start.getDay() + 6) % 7;
    for (let i = 0; i < offset; i++) {
        const empty = document.createElement('div');
        empty.className = 'calendar-day';
        cal.appendChild(empty);
    }
    for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
        const dateStr = d.toISOString().split('T')[0];
        const sessionIndex = userData.trainingPlan.findIndex(s => s.date === dateStr);
        const session = userData.trainingPlan[sessionIndex];
        let icon = 'üò¥';
        let cls = 'session-rest';
        if (session) {
            if (session.type === 'interval') {
                icon = '‚ö°';
                cls = 'session-interval';
            } else {
                icon = 'üê¢';
                cls = 'session-easy';
            }
        }
        const cell = document.createElement('div');
        cell.className = 'calendar-day';
        if (session && session.completed) {
            cell.classList.add('completed');
        }
        const star = session && session.completed ? '<span class="done-star">‚≠ê</span>' : '';
        cell.innerHTML = `<span class="session-icon ${cls}">${icon}</span>${d.getDate()}${star}`;
        if (session) {
            if (session.completed) {
                const runIndex = userData.runs.findIndex(r => r.date === session.date && r.type === session.type);
                if (runIndex !== -1) {
                    cell.addEventListener('click', () => showRunDetails(runIndex));
                }
            } else {
                cell.addEventListener('click', () => {
                    startSelectedSession(sessionIndex);
                });
            }
        } else {
            cell.addEventListener('click', () => {
                alert("Bon repos ! Le repos est essentiel pour progresser.");
            });
        }
        cal.appendChild(cell);
    }
}

function updateGoalProgress() {
    const progressEl = document.getElementById('goal-progress');
    const textEl = document.getElementById('progress-text');
    if (!progressEl || !textEl || !userData.eventDate) return;
    const start = userData.trainingPlan.length ? new Date(userData.trainingPlan[0].date) : new Date();
    const end = new Date(userData.eventDate);
    const now = new Date();
    const total = end - start;
    const done = now - start;
    const percent = total > 0 ? Math.min(100, Math.max(0, Math.round((done / total) * 100))) : 0;
    progressEl.value = percent;
    textEl.textContent = percent + '%';
}
        // Mettre √† jour les statistiques affich√©es
        function updateStats() {
            if (userData.runs.length === 0 || typeof Chart === 'undefined') return;
            
            // Calculer les totaux
            const totalRuns = userData.runs.length;
            const totalDistance = userData.runs.reduce((sum, run) => sum + parseFloat(run.distance), 0).toFixed(1);
            
            // Calculer les meilleurs rythmes
            const paces = userData.runs.map(run => paceToSeconds(run.pace));
            const bestPace = secondsToPace(Math.min(...paces));
            const avgPace = secondsToPace(paces.reduce((sum, pace) => sum + pace, 0) / paces.length);
            
            // Mettre √† jour l'affichage
            document.getElementById('total-runs').textContent = totalRuns;
            document.getElementById('total-distance').textContent = totalDistance;
            document.getElementById('best-pace').textContent = bestPace;
            document.getElementById('avg-pace').textContent = avgPace;
            
            // Mettre √† jour les graphiques
            updatePaceChart();
            updateWeeklyDistanceChart();
            updateSpeedHistogramChart();
            updateMonthlyGoalChart();
        }
        
        // Mettre √† jour le graphique de progression du rythme
        function updatePaceChart() {
            if (typeof Chart === 'undefined') return;
            const ctx = document.getElementById('pace-chart').getContext('2d');
            
            // Trier les courses par date
            const sortedRuns = [...userData.runs].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Pr√©parer les donn√©es
            const labels = sortedRuns.map(run => new Date(run.date).toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' }));
            const paces = sortedRuns.map(run => {
                const [mins, secs] = run.pace.split(':').map(Number);
                return mins + secs / 60;
            });
            
            // Cr√©er ou mettre √† jour le graphique
            if (window.paceChart) {
                window.paceChart.data.labels = labels;
                window.paceChart.data.datasets[0].data = paces;
                window.paceChart.update();
            } else {
                window.paceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Rythme (min/km)',
                            data: paces,
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            tension: 0.3,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                beginAtZero: false,
                                reverse: true,
                                title: {
                                    display: true,
                                    text: 'Rythme (min/km)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Date'
                                }
                            }
                        }
                    }
                });
            }
        }

        // Mettre √† jour la courbe des distances hebdomadaires
        function updateWeeklyDistanceChart() {
            if (typeof Chart === 'undefined') return;
            const ctx = document.getElementById('weekly-distance-chart').getContext('2d');

            const weeks = {};
            userData.runs.forEach(run => {
                const d = new Date(run.date);
                const day = d.getDay();
                const diff = d.getDate() - day + (day === 0 ? -6 : 1); // lundi
                const monday = new Date(d.setDate(diff));
                const key = monday.toISOString().split('T')[0];
                weeks[key] = (weeks[key] || 0) + parseFloat(run.distance);
            });

            const sorted = Object.keys(weeks).sort();
            const labels = sorted.map(date => new Date(date).toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' }));
            const distances = sorted.map(date => weeks[date].toFixed(1));

            if (window.weeklyDistanceChart) {
                weeklyDistanceChart.data.labels = labels;
                weeklyDistanceChart.data.datasets[0].data = distances;
                weeklyDistanceChart.update();
            } else {
                window.weeklyDistanceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Distance hebdomadaire (km)',
                            data: distances,
                            borderColor: '#2ecc71',
                            backgroundColor: 'rgba(46, 204, 113, 0.1)',
                            tension: 0.3,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: { beginAtZero: true }
                        }
                    }
                });
            }
        }

        // Mettre √† jour l'histogramme des vitesses
        function updateSpeedHistogramChart() {
            if (typeof Chart === 'undefined') return;
            const ctx = document.getElementById('speed-histogram-chart').getContext('2d');
            const bins = {};
            userData.runs.forEach(run => {
                const [mins, secs] = run.pace.split(':').map(Number);
                const speed = 60 / (mins + secs / 60);
                const bin = Math.floor(speed);
                bins[bin] = (bins[bin] || 0) + 1;
            });

            const sorted = Object.keys(bins).sort((a,b) => a - b);
            const labels = sorted.map(b => `${b}-${parseInt(b)+1} km/h`);
            const values = sorted.map(b => bins[b]);

            if (window.speedHistogramChart) {
                speedHistogramChart.data.labels = labels;
                speedHistogramChart.data.datasets[0].data = values;
                speedHistogramChart.update();
            } else {
                window.speedHistogramChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Nombre de courses',
                            data: values,
                            backgroundColor: '#e67e22'
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: { y: { beginAtZero: true } }
                    }
                });
            }
        }

        // Mettre √† jour le cercle de progression mensuel
        function updateMonthlyGoalChart() {
            if (typeof Chart === 'undefined') return;
            const ctx = document.getElementById('monthly-goal-chart').getContext('2d');
            const now = new Date();
            let monthDistance = 0;
            userData.runs.forEach(run => {
                const d = new Date(run.date);
                if (d.getMonth() === now.getMonth() && d.getFullYear() === now.getFullYear()) {
                    monthDistance += parseFloat(run.distance);
                }
            });

            const done = Math.min(monthDistance, MONTHLY_GOAL_KM);
            const remaining = Math.max(MONTHLY_GOAL_KM - done, 0);

            if (window.monthlyGoalChart) {
                monthlyGoalChart.data.datasets[0].data = [done, remaining];
                monthlyGoalChart.options.plugins.title.text = `${done.toFixed(1)} / ${MONTHLY_GOAL_KM} km`;
                monthlyGoalChart.update();
            } else {
                window.monthlyGoalChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['R√©alis√©', 'Restant'],
                        datasets: [{
                            data: [done, remaining],
                            backgroundColor: ['#3498db', '#ecf0f1'],
                            borderWidth: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { display: false },
                            title: { display: true, text: `${done.toFixed(1)} / ${MONTHLY_GOAL_KM} km` }
                        }
                    }
                });
            }
        }
        
        // Mettre √† jour l'historique des courses
        function updateHistory() {
            const tbody = document.getElementById('history-table');
            tbody.innerHTML = '';
            
            userData.runs.forEach((run, index) => {
                const tr = document.createElement('tr');
                const date = new Date(run.date);
                const formattedDate = date.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short', year: 'numeric' });
                
                tr.innerHTML = `
                    <td>${formattedDate}</td>
                    <td>${runTypes[run.type]?.name || run.type}</td>
                    <td>${run.distance} km</td>
                    <td>${run.pace} min/km</td>
                    <td>
                        <button class="btn" onclick="showRunDetails(${index})"><i class="fas fa-eye"></i> Voir</button>
                    </td>
                `;
                
                tbody.appendChild(tr);
            });
            
            // Mettre √† jour les statistiques
            updateStats();
        }
        
        // Afficher les d√©tails d'une course
        function showRunDetails(runIndex) {
            const run = userData.runs[runIndex];
            if (!run) return;
            
            // Masquer toutes les sections
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Afficher la section de d√©tail
            document.getElementById('run-detail-section').classList.add('active');
            
            // Mettre √† jour les informations de la course
            document.getElementById('run-date').textContent = new Date(run.date).toLocaleDateString('fr-FR', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
            
            document.getElementById('run-detail-distance').textContent = run.distance;
            document.getElementById('run-detail-duration').textContent = formatTime(run.duration);
            document.getElementById('run-detail-pace').textContent = run.pace;
            
            // Afficher l'image du trac√© si disponible
            if (run.routeImage) {
                document.getElementById('route-image').src = run.routeImage;
                document.getElementById('route-image').style.display = 'block';
            } else {
                document.getElementById('route-image').style.display = 'none';
            }
            
            // Calculer l'√©l√©vation si disponible
            let totalElevation = 0;
            if (run.gpsData && run.gpsData.length > 0) {
                for (let i = 1; i < run.gpsData.length; i++) {
                    if (run.gpsData[i].altitude && run.gpsData[i-1].altitude) {
                        const diff = run.gpsData[i].altitude - run.gpsData[i-1].altitude;
                        if (diff > 0) totalElevation += diff;
                    }
                }
            }
            document.getElementById('run-detail-elevation').textContent = Math.round(totalElevation);
            
            // Calculer le meilleur kilom√®tre si les donn√©es sont disponibles
            let bestPace = "N/A";
            if (run.splits && run.splits.length > 0) {
                const splitsPace = run.splits.map(split => paceToSeconds(split.pace));
                bestPace = secondsToPace(Math.min(...splitsPace));
            }
            document.getElementById('run-detail-best-pace').textContent = bestPace;
            
            // Afficher les splits
            const splitsTbody = document.getElementById('run-splits');
            splitsTbody.innerHTML = '';
            
            if (run.splits && run.splits.length > 0) {
                run.splits.forEach((split, index) => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `
                        <td>${index + 1}</td>
                        <td>${formatTime(split.duration)}</td>
                        <td>${split.pace} min/km</td>
                    `;
                    splitsTbody.appendChild(tr);
                });
            } else {
                splitsTbody.innerHTML = '<tr><td colspan="3">Aucun d√©tail par kilom√®tre disponible</td></tr>';
            }
            
            // Configurer les boutons
            document.getElementById('share-run-btn').onclick = () => shareRun(run);
            document.getElementById('export-gpx-btn').onclick = () => exportToGPX(run);
            document.getElementById('strava-upload-btn').onclick = () => publishToStrava(run);
            document.getElementById('back-to-stats-btn').onclick = () => {
                document.getElementById('run-detail-section').classList.remove('active');
                document.getElementById('nav-stats').classList.add('active');
                document.getElementById('stats-section').classList.add('active');
            };
        }
        
        // Capturer une image de la carte
        async function captureRouteImage() {
            if (!mapObject || typeof html2canvas === 'undefined') return null;
            
            try {
                // Cr√©er un conteneur temporaire pour la capture
                const tempContainer = document.createElement('div');
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-9999px';
                tempContainer.style.width = '300px';
                tempContainer.style.height = '200px';
                document.body.appendChild(tempContainer);
                
                // Cr√©er une carte temporaire
                const tempMap = L.map(tempContainer).setView(mapObject.getCenter(), mapObject.getZoom());
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(tempMap);
                
                // Ajouter le trac√©
                if (locationData.length > 1) {
                    const points = locationData.map(loc => [loc.latitude, loc.longitude]);
                    L.polyline(points, {color: '#3498db', weight: 3}).addTo(tempMap);
                    
                    // Ajouter des marqueurs de d√©but et fin
                    L.circleMarker(points[0], {
                        color: '#2ecc71',
                        fillColor: '#2ecc71',
                        fillOpacity: 1,
                        radius: 5
                    }).addTo(tempMap).bindPopup("D√©part");
                    
                    L.circleMarker(points[points.length - 1], {
                        color: '#e74c3c',
                        fillColor: '#e74c3c',
                        fillOpacity: 1,
                        radius: 5
                    }).addTo(tempMap).bindPopup("Arriv√©e");
                    
                    // Ajuster la vue
                    tempMap.fitBounds(L.polyline(points).getBounds());
                }
                
                // Attendre que la carte se charge
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Capturer l'image
                const canvas = await html2canvas(tempContainer, {
                    backgroundColor: null,
                    scale: 1,
                    logging: false,
                    useCORS: true
                });
                
                // Nettoyer
                tempMap.remove();
                document.body.removeChild(tempContainer);
                
                return canvas.toDataURL('image/png');
            } catch (error) {
                console.error('Erreur lors de la capture de la carte:', error);
                return null;
            }
        }
        
        // Fermer le modal
        document.querySelector('.close-modal').addEventListener('click', function() {
            document.getElementById('run-details-modal').style.display = 'none';
            
            // Supprimer la carte pour √©viter les conflits
            if (runMapObject) {
                runMapObject.remove();
                runMapObject = null;
            }
        });
        
        // Navigation entre les sections
        const sections = ['plan', 'run', 'stats', 'profile', 'create-plan'];
        
        sections.forEach(section => {
            document.getElementById(`nav-${section}`).addEventListener('click', () => {
                // D√©sactiver tous les boutons et sections
                sections.forEach(s => {
                    document.getElementById(`nav-${s}`).classList.remove('active');
                    document.getElementById(`${s}-section`).classList.remove('active');
                });
                
                // Activer le bouton et la section cliqu√©s
                document.getElementById(`nav-${section}`).classList.add('active');
                document.getElementById(`${section}-section`).classList.add('active');
            });
        });
        
        // Gestion du formulaire de profil
        document.getElementById('profile-form').addEventListener('submit', function(e) {
            e.preventDefault();
            
            // Mettre √† jour les donn√©es utilisateur
            userData.currentPace = document.getElementById('current-pace-input').value;
            userData.targetPace = document.getElementById('target-pace-input').value;
            userData.eventDate = document.getElementById('event-date-input').value;
            userData.stravaToken = document.getElementById('strava-token-input').value;
            document.getElementById('strava-status').textContent = userData.stravaToken ? 'Connect√©' : 'Non connect√©';
            
            // Mettre √† jour les jours d'entra√Ænement
            userData.trainingDays = [];
            const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
            days.forEach(day => {
                if (document.getElementById(day).checked) {
                    userData.trainingDays.push(day);
                }
            });
            
            // Mettre √† jour les instructions vocales
            userData.voiceEnabled = document.getElementById('voice-enabled').checked;
            
            // Sauvegarder dans le stockage local
            localStorage.setItem('runPacerUserData', JSON.stringify(userData));
            
            // Mettre √† jour l'affichage
            updateProfileDisplay();
            generateTrainingPlan();
            
            // Afficher un message de confirmation
            alert('Vos modifications ont √©t√© enregistr√©es!');
        });
        
        // Mettre √† jour l'affichage du profil
        function updateProfileDisplay() {
            document.getElementById('header-objective').textContent = `Atteignez votre objectif de ${userData.targetPace} min/km`;
            
            const eventDate = new Date(userData.eventDate);
            const formattedDate = eventDate.toLocaleDateString('fr-FR', { day: 'numeric', month: 'long', year: 'numeric' });
            
            document.getElementById('goal-event').innerHTML = `Course 10km: <strong>${formattedDate}</strong>`;
            document.getElementById('goal-pace').innerHTML = `Objectif rythme: <strong>${userData.targetPace} min/km</strong>`;
            document.getElementById('current-level').innerHTML = `Niveau actuel: <strong>${userData.currentPace} min/km</strong>`;
            
            // Formater les jours d'entra√Ænement
            const dayNames = {
                monday: 'Lundi',
                tuesday: 'Mardi',
                wednesday: 'Mercredi',
                thursday: 'Jeudi',
                friday: 'Vendredi',
                saturday: 'Samedi',
                sunday: 'Dimanche'
            };
            
            const trainingDaysStr = userData.trainingDays.map(day => dayNames[day]).join(', ');
            document.getElementById('training-days').innerHTML = `Jours d'entra√Ænement: <strong>${trainingDaysStr}</strong>`;
        }
        
        // Lien entre le bouton "Commencer la s√©ance" et la section "Courir"
        document.getElementById('start-run-btn').addEventListener('click', () => {
            // D√©sactiver tous les boutons et sections
            sections.forEach(s => {
                document.getElementById(`nav-${s}`).classList.remove('active');
                document.getElementById(`${s}-section`).classList.remove('active');
            });
            
            // Activer la section "Courir"
            document.getElementById('nav-run').classList.add('active');
            document.getElementById('run-section').classList.add('active');
            
            // D√©finir le rythme cible en fonction du type de course
            const runType = runTypes[currentRunType];
            const currentPaceSeconds = paceToSeconds(userData.currentPace);
            const targetPaceSeconds = currentPaceSeconds + (runType.paceOffset * 60);
            
            document.getElementById('target-pace').textContent = secondsToPace(targetPaceSeconds);
            
            // D√©marrer la simulation de course
            startRun();
        });
        
        // Gestion du changement de type de course
        document.querySelectorAll('input[name="run-type"]').forEach(radio => {
            radio.addEventListener('change', function() {
                if (this.checked) {
                    currentRunType = this.value;
                    const runType = runTypes[currentRunType];
                    
                    // Mettre √† jour le rythme cible si la course n'a pas encore commenc√©
                    if (!isRunning) {
                        const currentPaceSeconds = paceToSeconds(userData.currentPace);
                        const targetPaceSeconds = currentPaceSeconds + (runType.paceOffset * 60);
                        document.getElementById('target-pace').textContent = secondsToPace(targetPaceSeconds);
                    }
                }
            });
        });
        
        // Initialiser la carte avec Leaflet
        function initializeMap() {
            // V√©rifier si la carte est d√©j√† initialis√©e
            if (mapObject) return;
            
            const mapElement = document.getElementById('map');
            
            // Si Leaflet est disponible, initialiser la carte
            if (typeof L !== 'undefined') {
                mapObject = L.map('map').setView([48.8566, 2.3522], 15); // Paris par d√©faut
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(mapObject);
                
                // Cr√©er un layer pour le parcours
                window.routeLayer = L.layerGroup().addTo(mapObject);
            } else {
                // Fallback si Leaflet n'est pas disponible
                mapElement.innerHTML = '<div style="background-color: #e0e0e0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;"><i class="fas fa-map-marker-alt" style="font-size: 2rem; color: #3498db;"></i><span style="margin-left: 10px;">Carte non disponible</span></div>';
            }
        }
        
        // Demander les permissions de localisation
        function requestLocationPermission() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject("La g√©olocalisation n'est pas support√©e par votre navigateur.");
                    return;
                }
                
                navigator.geolocation.getCurrentPosition(
                    position => resolve(position),
                    error => {
                        console.error('Erreur de g√©olocalisation:', error);
                        
                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                                reject('Vous avez refus√© l\'acc√®s √† votre position.');
                                break;
                            case error.POSITION_UNAVAILABLE:
                                reject('Information de localisation non disponible.');
                                break;
                            case error.TIMEOUT:
                                reject('D√©lai d\'attente d√©pass√© pour obtenir la position.');
                                break;
                            case error.UNKNOWN_ERROR:
                                reject('Une erreur inconnue s\'est produite.');
                                break;
                        }
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    }
                );
            });
        }
        
        <!-- calculateDistance d√©fini dans utils.js -->
        
        // Mettre √† jour la carte avec les nouvelles coordonn√©es
        function updateMap(latitude, longitude) {
            if (!mapObject || typeof L === 'undefined') return;
            
            // Centrer la carte sur la position actuelle
            mapObject.setView([latitude, longitude], 16);
            
            // Ajouter un point au parcours
            if (locationData.length > 1) {
                const lastLocation = locationData[locationData.length - 2];
                const routeLine = L.polyline(
                    [
                        [lastLocation.latitude, lastLocation.longitude],
                        [latitude, longitude]
                    ],
                    {color: 'blue', weight: 5}
                );
                window.routeLayer.addLayer(routeLine);
            }
            
            // Ajouter un marqueur √† la position actuelle (et supprimer l'ancien s'il existe)
            if (window.currentPositionMarker) {
                mapObject.removeLayer(window.currentPositionMarker);
            }
            window.currentPositionMarker = L.circleMarker([latitude, longitude], {
                color: '#3498db',
                fillColor: '#3498db',
                fillOpacity: 1,
                radius: 8
            }).addTo(mapObject);
        }
        
        // Gestion des mises √† jour de position GPS
        function handleLocationUpdate(position) {
            const { latitude, longitude, accuracy, speed, altitude } = position.coords;
            const timestamp = position.timestamp;
            
            // Ne garder que les points avec une pr√©cision suffisante (accuracy < 20 m√®tres)
            if (accuracy > 20) {
                console.log("Point GPS ignor√© (pr√©cision insuffisante):", accuracy);
                return;
            }
            
            // Ajouter aux donn√©es de localisation avec plus d'infos
            locationData.push({ 
                latitude, 
                longitude, 
                accuracy, 
                speed, 
                altitude,
                timestamp 
            });
            
            // Calculer la distance si ce n'est pas le premier point
            if (previousLocation) {
                const segmentDistance = calculateDistance(
                    previousLocation.latitude, previousLocation.longitude,
                    latitude, longitude
                );
                
                // Filtrer les mauvaises lectures GPS (si la distance est trop grande en peu de temps)
                const timeElapsed = (timestamp - previousLocation.timestamp) / 1000; // en secondes
                const speedMps = segmentDistance / timeElapsed;
                
                // Ignorer les points aberrants (vitesse > 10 m/s ou 36 km/h)
                if (segmentDistance > 1 && speedMps < 10) {
        distanceTraveled += segmentDistance;
        
        // Gestion sp√©cifique des intervalles
        if (runTypes[currentRunType].isInterval) {
            intervalDistanceRemaining -= segmentDistance;

            // V√©rifier si on doit changer de phase
            if (intervalDistanceRemaining <= 0) {
                if (intervalPhase === 'work') {
                    intervalPhase = 'recovery';
                    intervalDistanceRemaining = runTypes[currentRunType].recoveryDuration;
                    currentTargetPace = secondsToPace(
                        paceToSeconds(userData.currentPace) +
                        runTypes[currentRunType].recoveryPaceOffset * 60
                    );
                } else {
                    intervalPhase = 'work';
                    intervalDistanceRemaining = runTypes[currentRunType].intervalDuration;
                    currentTargetPace = secondsToPace(
                        paceToSeconds(userData.currentPace) +
                        runTypes[currentRunType].paceOffset * 60
                    );
                }

                vibratePhone();
                announceInterval(intervalPhase);
            }

            updateIntervalIndicator();
            // Mettre √† jour l'affichage du rythme cible
            document.getElementById('target-pace').textContent = currentTargetPace;
        }
            
                    
                    // V√©rifier si un nouveau kilom√®tre a √©t√© parcouru
                    const currentKm = Math.floor(distanceTraveled / 1000);
                    const previousKm = Math.floor((distanceTraveled - segmentDistance) / 1000);
                    
                    if (currentKm > previousKm) {
                        // Enregistrer le split du kilom√®tre
                        const kmDuration = currentDuration - currentKmStartTime;
                        const kmPace = secondsToPace(kmDuration / (1)); // 1 km
                        
                        kmSplits.push({
                            km: currentKm,
                            distance: 1, // 1 km
                            duration: kmDuration,
                            pace: kmPace
                        });
                        
                        currentKmStartTime = currentDuration;
                        currentKmStartDistance = distanceTraveled;
                        
                        // Instruction vocale pour le kilom√®tre parcouru
                        if (userData.voiceEnabled) {
                            const paceSpeech = paceToSpeech(kmPace);
                            const utterance = new SpeechSynthesisUtterance(`Kilom√®tre ${currentKm} en ${paceSpeech}`);
                            utterance.lang = 'fr-FR';
                            speechSynthesis.speak(utterance);
                            
                            // Afficher l'indicateur vocal
                            document.getElementById('voice-indicator').classList.remove('hidden');
                            setTimeout(() => {
                                document.getElementById('voice-indicator').classList.add('hidden');
                            }, 3000);
                        }
                    }
                    
                    // Mettre √† jour l'affichage
                    document.getElementById('distance').textContent = (distanceTraveled / 1000).toFixed(2);
                    
                    // Calculer le rythme actuel en min/km
                    let currentPaceSeconds;
                    if (speed && speed > 0) {
                        // Utiliser la vitesse du GPS si disponible (en m/s)
                        currentPaceSeconds = (1000 / speed) / 60; // Convertir en min/km
                    } else {
                        // Calculer √† partir de la distance et du temps
                        const currentSpeed = segmentDistance / timeElapsed; // m/s
                        if (currentSpeed > 0) {
                            currentPaceSeconds = (1000 / currentSpeed) / 60; // min/km
                        } else {
                            currentPaceSeconds = 0;
                        }
                    }
                    
                    // Mettre √† jour l'affichage du rythme
                    if (currentPaceSeconds > 0) {
                        const paceMinutes = Math.floor(currentPaceSeconds);
                        const paceSeconds = Math.floor((currentPaceSeconds - paceMinutes) * 60);
                        document.getElementById('current-pace').textContent = 
                            `${paceMinutes}:${paceSeconds.toString().padStart(2, '0')}`;
                        
                        // Feedback sur le rythme
                        updatePaceFeedback(currentPaceSeconds * 60); // Convertir en secondes
                    }
                    
                    // Mettre √† jour la carte
                    updateMap(latitude, longitude);
                }
            } else {
                // Premier point, initialiser la carte
                updateMap(latitude, longitude);
                currentKmStartTime = currentDuration;
                currentKmStartDistance = 0;
            }
            
            previousLocation = { latitude, longitude, timestamp };
        }
        
        // D√©marrer le suivi GPS
        function startGpsTracking() {
            if (navigator.geolocation) {
                watchId = navigator.geolocation.watchPosition(
                    handleLocationUpdate,
                    error => {
                        console.error('Erreur de g√©olocalisation:', error);
                        alert(`Erreur GPS: ${error.message}`);
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    }
                );
                isTrackingLocation = true;
            } else {
                alert('La g√©olocalisation n\'est pas support√©e par votre navigateur.');
            }
        }
        
        // Arr√™ter le suivi GPS
        function stopGpsTracking() {
            if (watchId !== undefined) {
                navigator.geolocation.clearWatch(watchId);
                watchId = undefined;
                isTrackingLocation = false;
            }
        }
        
        // Mettre √† jour le feedback de rythme
        function updatePaceFeedback(currentPaceSeconds) {
    const targetPaceSeconds = paceToSeconds(currentTargetPace);
    const paceFeedback = document.getElementById('pace-feedback');
            
            if (currentPaceSeconds < targetPaceSeconds - 15) {
                paceFeedback.textContent = "Ralentissez un peu!";
                paceFeedback.className = "too-fast";
                
                // Instruction vocale si n√©cessaire
                if (userData.voiceEnabled && currentDuration - lastSpokenTime > 60) {
                    const utterance = new SpeechSynthesisUtterance("Ralentissez un peu, vous √™tes trop puissant et rapide. Unlimited power.");
                    utterance.lang = 'fr-FR';
                    speechSynthesis.speak(utterance);
                    lastSpokenTime = currentDuration;
                    
                    // Afficher l'indicateur vocal
                    document.getElementById('voice-indicator').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('voice-indicator').classList.add('hidden');
                    }, 3000);
                }
            } else if (currentPaceSeconds > targetPaceSeconds + 15) {
                const message = slowPhrases[Math.floor(Math.random()*slowPhrases.length)];
                paceFeedback.textContent = message;
                paceFeedback.className = "too-slow";
                
                // Instruction vocale si n√©cessaire
                if (userData.voiceEnabled && currentDuration - lastSpokenTime > 60) {
                    const utterance = new SpeechSynthesisUtterance(message);
                    utterance.lang = 'fr-FR';
                    speechSynthesis.speak(utterance);
                    lastSpokenTime = currentDuration;
                    
                    // Afficher l'indicateur vocal
                    document.getElementById('voice-indicator').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('voice-indicator').classList.add('hidden');
                    }, 3000);
                }
            } else {
                paceFeedback.textContent = "Bon rythme, continuez!";
                paceFeedback.className = "good-pace";
            }
        }
        
        // Fonction pour d√©marrer la course
        async function startRun(resume = false) {
    // R√©initialiser les variables
    if (!resume) {
        runStartTimestamp = Date.now();
        runStartTime = new Date(runStartTimestamp).toISOString();
    }
    isRunning = true;
    currentDuration = 0;
    distanceTraveled = 0;
    locationData = [];
    previousLocation = null;
    kmSplits = [];
    currentKmStartTime = 0;
    currentKmStartDistance = 0;
    currentRouteImage = null;

    // Utiliser le rythme cible de la session s√©lectionn√©e
    const targetPace = document.getElementById('target-pace').textContent;
    currentTargetPace = targetPace;

    // Initialiser les intervalles si n√©cessaire
    if (runTypes[currentRunType].isInterval) {
        intervalPhase = 'work';
        intervalDistanceRemaining = runTypes[currentRunType].intervalDuration;

        updateIntervalIndicator();

        // Premi√®re annonce
        if (userData.voiceEnabled) {
            const utterance = new SpeechSynthesisUtterance("D√©but des intervalles. Premier intervalle rapide.");
            utterance.lang = 'fr-FR';
            speechSynthesis.speak(utterance);
        }
    }
    
    // Initialiser la carte
    initializeMap();
    
    // Nettoyer le parcours pr√©c√©dent sur la carte
    if (window.routeLayer) {
        window.routeLayer.clearLayers();
    }
    
    // R√©initialiser l'affichage
    document.getElementById('current-pace').textContent = "--:--";
    document.getElementById('distance').textContent = "0.00";
    document.getElementById('duration').textContent = "00:00";
    document.getElementById('pace-feedback').textContent = "Course en cours...";
    document.getElementById('pace-feedback').className = "good-pace";
    
    // Activer/d√©sactiver les boutons
    document.getElementById('pause-btn').innerHTML = '<i class="fas fa-pause"></i>';
    document.getElementById('pause-btn').onclick = pauseRun;
    document.getElementById('stop-btn').disabled = false;
    
    // D√©marrer le chrono
    runInterval = setInterval(updateRunningTime, 1000);
    
    // D√©marrer le GPS
    startGpsTracking();
    
    // Instruction vocale
    if (userData.voiceEnabled) {
        const runType = runTypes[currentRunType];
        const targetPaceSpeech = paceToSpeech(document.getElementById('target-pace').textContent);
        const utterance = new SpeechSynthesisUtterance(`D√©but de la ${runType.name.toLowerCase()}. Objectif: ${targetPaceSpeech} par kilom√®tre.`);
        utterance.lang = 'fr-FR';
        speechSynthesis.speak(utterance);
        
        // Afficher l'indicateur vocal
        document.getElementById('voice-indicator').classList.remove('hidden');
        setTimeout(() => {
            document.getElementById('voice-indicator').classList.add('hidden');
        }, 3000);
    }

    // Enregistrer le Service Worker pour le suivi en arri√®re-plan
    if ('serviceWorker' in navigator) {
        try {
            const registration = await navigator.serviceWorker.ready;
            
            // Stocker les donn√©es de course pour l'arri√®re-plan
            const runData = {
                startTime: runStartTimestamp,
                runType: currentRunType,
                targetPace: currentTargetPace,
                locations: []
            };
            
            if (navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({
                    type: 'SET_BACKGROUND_RUN',
                    runData: runData
                });
            }

            // Enregistrer la synchronisation si l'API est disponible
            if ('SyncManager' in window) {
                try {
                    await registration.sync.register('sync-run-data');
                    console.log('Sync registered for background tracking');
                } catch (e) {
                    console.log('Sync registration failed:', e);
                }
            }
        } catch (error) {
            console.error('Service Worker error:', error);
        }
    }

    // D√©marrer le suivi en arri√®re-plan si l'application est ferm√©e
    if ('wakeLock' in navigator) {
        try {
            const wakeLock = await navigator.wakeLock.request('screen');
            wakeLock.addEventListener('release', () => {
                console.log('Wake Lock was released');
            });
            console.log('Wake Lock is active');
        } catch (err) {
            console.error('Wake Lock error:', err);
        }
    }
}

        // Stocker les donn√©es de course p√©riodiquement
function storeRunDataPeriodically() {
    if (!isRunning) return;
    
    const runData = {
        startTime: runStartTimestamp,
        currentDuration: currentDuration,
        distanceTraveled: distanceTraveled,
        locations: locationData,
        kmSplits: kmSplits,
        runType: currentRunType,
        targetPace: currentTargetPace
    };
    
    localStorage.setItem('currentRunData', JSON.stringify(runData));
    
    // Envoyer au Service Worker
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({
            type: 'UPDATE_BACKGROUND_RUN',
            runData: runData
        });
    }
    
    setTimeout(storeRunDataPeriodically, 10000); // Toutes les 10 secondes
}

// R√©cup√©rer les donn√©es de course interrompue
function recoverInterruptedRun() {
    const savedRun = localStorage.getItem('currentRunData');
    if (savedRun) {
        const runData = JSON.parse(savedRun);
        
        // V√©rifier si la course √©tait en cours (moins de 1h depuis le dernier enregistrement)
        const timeSinceLastUpdate = new Date().getTime() - (runData.startTime + (runData.currentDuration * 1000));
        if (timeSinceLastUpdate < 3600000) { // 1 heure
            const shouldResume = confirm("Une course en cours a √©t√© d√©tect√©e. Voulez-vous reprendre ?");
            if (shouldResume) {
                // Restaurer les donn√©es
                currentDuration = runData.currentDuration;
                distanceTraveled = runData.distanceTraveled;
                locationData = runData.locations || [];
                kmSplits = runData.kmSplits || [];
                currentRunType = runData.runType || 'easy';
                currentTargetPace = runData.targetPace || userData.targetPace;
                
                // Red√©marrer la course
                runStartTimestamp = runData.startTime;
                runStartTime = new Date(runData.startTime).toISOString();
                startRun(true);
                
                // Mettre √† jour l'affichage
                document.getElementById('distance').textContent = (distanceTraveled / 1000).toFixed(2);
                document.getElementById('duration').textContent = formatTime(currentDuration);
                
                // Restaurer la carte si possible
                if (locationData.length > 0 && mapObject) {
                    updateMap(locationData[locationData.length-1].latitude, 
                             locationData[locationData.length-1].longitude);
                    
                    // Redessiner le parcours
                    if (window.routeLayer) {
                        window.routeLayer.clearLayers();
                        const points = locationData.map(loc => [loc.latitude, loc.longitude]);
                        L.polyline(points, {color: 'blue', weight: 5}).addTo(window.routeLayer);
                    }
                }
                
                return true;
            }
        }
        
        // Nettoyer si l'utilisateur ne veut pas reprendre
        localStorage.removeItem('currentRunData');
    }
    return false;
}

// G√©rer la reprise apr√®s arri√®re-plan
function handleAppResume() {
  if (isBackgroundRun) {
    // R√©cup√©rer les donn√©es du Service Worker
    if (navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage({
        type: 'GET_BACKGROUND_RUN'
      });
    }

    // Reprendre le suivi sans r√©initialiser
    isBackgroundRun = false;
    if (!runInterval) {
      runInterval = setInterval(updateRunningTime, 1000);
    }
    if (!isTrackingLocation) {
      startGpsTracking();
    }
  }
}

// √âcouter les messages du Service Worker
navigator.serviceWorker.addEventListener('message', event => {
  if (event.data.type === 'BACKGROUND_RUN_DATA') {
    const runData = event.data.runData;
    // Traiter les donn√©es r√©cup√©r√©es de l'arri√®re-plan
    console.log('Donn√©es r√©cup√©r√©es:', runData);
    
    // Mettre √† jour l'interface avec les donn√©es
    if (runData.locations.length > 0) {
      locationData = runData.locations;
      distanceTraveled = calculateTotalDistance(runData.locations);
      runStartTimestamp = runData.startTime;
      runStartTime = new Date(runData.startTime).toISOString();
      currentDuration = Math.floor((Date.now() - runStartTimestamp) / 1000);
      
      // Mettre √† jour l'affichage
      document.getElementById('distance').textContent = (distanceTraveled / 1000).toFixed(2);
      document.getElementById('duration').textContent = formatTime(currentDuration);
      
      // Recalculer le rythme
      if (distanceTraveled > 0 && currentDuration > 0) {
        const paceSeconds = (currentDuration / (distanceTraveled / 1000));
        const avgPace = secondsToPace(paceSeconds);
        document.getElementById('current-pace').textContent = avgPace;
      }
    }
  }
});

// Calculer la distance totale √† partir des points GPS
function calculateTotalDistance(locations) {
  let total = 0;
  for (let i = 1; i < locations.length; i++) {
    total += calculateDistance(
      locations[i-1].latitude, locations[i-1].longitude,
      locations[i].latitude, locations[i].longitude
    );
  }
  return total;
}

// √âcouter les √©v√©nements de visibilit√© de la page
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'hidden') {
    // L'application passe en arri√®re-plan
    if (isRunning) {
      isBackgroundRun = true;
      console.log('Application en arri√®re-plan, suivi continu');
    }
  } else {
    // L'application revient au premier plan
    handleAppResume();
  }
});

// Sauvegarder automatiquement le plan d'entra√Ænement
function saveTrainingPlan() {
  localStorage.setItem('runPacerTrainingPlan', JSON.stringify(userData.trainingPlan));
}

// Charger le plan d'entra√Ænement au d√©marrage
function loadTrainingPlan() {
  const savedPlan = localStorage.getItem('runPacerTrainingPlan');
  if (savedPlan) {
    userData.trainingPlan = JSON.parse(savedPlan);
    updateTrainingPlanDisplay();
  }
}

// Appeler loadTrainingPlan au d√©marrage sera g√©r√© plus loin
        
        
        
        // Mettre √† jour uniquement le temps qui s'√©coule
        function updateRunningTime() {
            currentDuration++;
            document.getElementById('duration').textContent = formatTime(currentDuration);
            
            // Annoncer la distance tous les kilom√®tres (fallback si GPS non disponible)
            if (distanceTraveled === 0) {
                const simulatedDistance = currentDuration / 300 * 1000; // Simuler 5:00 min/km
                const currentKm = Math.floor(simulatedDistance / 1000);
                
                if (currentKm > 0 && currentKm > Math.floor((simulatedDistance - 100) / 1000)) {
                    if (userData.voiceEnabled) {
                        const pace = secondsToPace(currentDuration / currentKm);
                        const paceSpeech = paceToSpeech(pace);
                        const utterance = new SpeechSynthesisUtterance(`Kilom√®tre ${currentKm} simul√© en ${paceSpeech}`);
                        utterance.lang = 'fr-FR';
                        speechSynthesis.speak(utterance);
                        
                        // Afficher l'indicateur vocal
                        document.getElementById('voice-indicator').classList.remove('hidden');
                        setTimeout(() => {
                            document.getElementById('voice-indicator').classList.add('hidden');
                        }, 3000);
                    }
                }
            }
        }
        
        // Fonction pour mettre en pause la course
        function pauseRun() {
    isRunning = false;
    clearInterval(runInterval);
    stopGpsTracking();
    
    // Mettre √† jour l'affichage des boutons
    document.getElementById('pause-btn').innerHTML = '<i class="fas fa-play"></i>';
    document.getElementById('pause-btn').onclick = resumeRun;
    document.getElementById('pace-feedback').textContent = "Course en pause";
    
    // Sauvegarder l'√©tat actuel
    storeRunDataPeriodically();
    
    // Instruction vocale
    if (userData.voiceEnabled) {
        const utterance = new SpeechSynthesisUtterance("Course en pause");
        utterance.lang = 'fr-FR';
        speechSynthesis.speak(utterance);
    }
}

        
        // Fonction pour reprendre la course
        function resumeRun() {
            isRunning = true;
            runInterval = setInterval(updateRunningTime, 1000);
            startGpsTracking();
            
            // Mettre √† jour l'affichage des boutons
            document.getElementById('pause-btn').innerHTML = '<i class="fas fa-pause"></i>';
            document.getElementById('pause-btn').onclick = pauseRun;
            document.getElementById('pace-feedback').textContent = "Course en cours...";
            
            // Instruction vocale
            if (userData.voiceEnabled) {
                const utterance = new SpeechSynthesisUtterance("Reprise de la course");
                utterance.lang = 'fr-FR';
                speechSynthesis.speak(utterance);
                
                // Afficher l'indicateur vocal
                document.getElementById('voice-indicator').classList.remove('hidden');
                setTimeout(() => {
                    document.getElementById('voice-indicator').classList.add('hidden');
                }, 3000);
            }
        }
        
        // Fonction pour arr√™ter la course
        document.getElementById('stop-btn').addEventListener('click', async function() {
            if (isRunning || document.getElementById('pause-btn').innerHTML.includes('fa-play')) {
                clearInterval(runInterval);
                stopGpsTracking();
                
                // Calculer le rythme moyen
                let avgPace = "--:--";
                if (distanceTraveled > 0 && currentDuration > 0) {
                    const paceSeconds = (currentDuration / (distanceTraveled / 1000));
                    avgPace = secondsToPace(paceSeconds);
                } else if (currentDuration > 0) {
                    // Fallback si pas de GPS: utiliser un rythme simul√©
                    avgPace = document.getElementById('target-pace').textContent;
                }
                
                // Instruction vocale
                if (userData.voiceEnabled) {
                    const paceSpeech = paceToSpeech(avgPace);
                    const utterance = new SpeechSynthesisUtterance(`Fin de la course. Rythme moyen: ${paceSpeech} par kilom√®tre.`);
                    utterance.lang = 'fr-FR';
                    speechSynthesis.speak(utterance);
                    
                    // Afficher l'indicateur vocal
                    document.getElementById('voice-indicator').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('voice-indicator').classList.add('hidden');
                    }, 3000);
                }
                
                // Capturer une image du trac√© si des donn√©es GPS sont disponibles
                let routeImage = null;
                if (locationData.length > 1) {
                    routeImage = await captureRouteImage();
                }
                
                // Sauvegarder la course seulement si une distance a √©t√© parcourue
                if (distanceTraveled > 0 || currentDuration > 60) {
                    const newRun = {
                        date: new Date(runStartTime).toISOString().split('T')[0],
                        startTime: runStartTime,
                        type: currentRunType,
                        typeName: runTypes[currentRunType].name,
                        distance: (distanceTraveled > 0 ? (distanceTraveled / 1000) : (currentDuration / paceToSeconds(avgPace))).toFixed(2),
                        pace: avgPace,
                        duration: currentDuration,
                        gpsData: locationData,
                        splits: kmSplits,
                        routeImage: routeImage
                    };
                    
                    userData.runs.unshift(newRun); // Ajouter au d√©but de l'historique
                    
                    // Marquer la s√©ance comme termin√©e dans le plan d'entra√Ænement
                    const today = new Date().toISOString().split('T')[0];
                    const sessionIndex = userData.trainingPlan.findIndex(session => session.date === today && session.type === currentRunType);
                    
                    if (sessionIndex !== -1) {
                        userData.trainingPlan[sessionIndex].completed = true;
                    }
                    
                    // Sauvegarder dans le stockage local
                    localStorage.setItem('runPacerUserData', JSON.stringify(userData));
                    
                    // Mise √† jour des statistiques
                    updateHistory();
                    updateTrainingPlanDisplay();
                }
                
                // Redirection vers la section des statistiques
                sections.forEach(s => {
                    document.getElementById(`nav-${s}`).classList.remove('active');
                    document.getElementById(`${s}-section`).classList.remove('active');
                });
                
                document.getElementById('nav-stats').classList.add('active');
                document.getElementById('stats-section').classList.add('active');
                
                // R√©initialiser l'interface de course
                isRunning = false;
                document.getElementById('current-pace').textContent = "--:--";
                document.getElementById('distance').textContent = "0.00";
                document.getElementById('duration').textContent = "00:00";
                document.getElementById('pause-btn').innerHTML = '<i class="fas fa-play"></i>';
                document.getElementById('pause-btn').onclick = startRun;
                document.getElementById('stop-btn').disabled = true;
                document.getElementById('pace-feedback').textContent = "Pr√™t √† commencer";
            }
        });
        
        // Charger les donn√©es utilisateur depuis le stockage local au d√©marrage
        window.addEventListener('DOMContentLoaded', function() {
    // Charger les donn√©es utilisateur
    const savedData = localStorage.getItem('runPacerUserData');
    if (savedData) {
        const parsedData = JSON.parse(savedData);
        Object.assign(userData, parsedData);
        
        // Mettre √† jour le formulaire avec les donn√©es sauvegard√©es
        document.getElementById('current-pace-input').value = userData.currentPace;
        document.getElementById('target-pace-input').value = userData.targetPace;
        document.getElementById('event-date-input').value = userData.eventDate;
        document.getElementById('strava-token-input').value = userData.stravaToken || '';
        document.getElementById('strava-status').textContent = userData.stravaToken ? 'Connect√©' : 'Non connect√©';
        document.getElementById('strava-connect-btn').onclick = connectStrava;

        const params = new URLSearchParams(window.location.search);
        if (params.has('code')) {
            exchangeStravaCode(params.get('code')).catch(e => alert('Erreur Strava: ' + e.message));
            history.replaceState({}, '', window.location.pathname);
        }
        
        // Jours d'entra√Ænement
        const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
        days.forEach(day => {
            document.getElementById(day).checked = userData.trainingDays.includes(day);
        });
        
        // Instructions vocales
        document.getElementById('voice-enabled').checked = userData.voiceEnabled;

        // Mettre √† jour l'affichage
        updateProfileDisplay();
        applyTheme(userData.theme || 'light');
    }
    else {
        applyTheme(userData.theme);
    }
    document.getElementById('theme-toggle').addEventListener('click', function() {
        userData.theme = document.body.classList.contains('dark-mode') ? 'light' : 'dark';
        applyTheme(userData.theme);
        localStorage.setItem('runPacerUserData', JSON.stringify(userData));
    });
    
    // Charger le plan d'entra√Ænement
    loadTrainingPlan();
    
    // V√©rifier s'il y a une course √† r√©cup√©rer
    if (!recoverInterruptedRun()) {
        // G√©n√©rer un plan d'entra√Ænement par d√©faut si aucun n'existe
        if (userData.trainingPlan.length === 0) {
            generateTrainingPlan();
        }
    }
    
    // V√©rifier la disponibilit√© de la synth√®se vocale
    if ('speechSynthesis' in window) {
        console.log("Synth√®se vocale disponible");
    } else {
        console.log("Synth√®se vocale non disponible");
        userData.voiceEnabled = false;
        document.getElementById('voice-enabled').checked = false;
        document.getElementById('voice-enabled').disabled = true;
    }
    
    // Initialiser une carte simple (placeholder)
    const mapElement = document.getElementById('map');
    mapElement.innerHTML = '<div style="background-color: #e0e0e0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;"><i class="fas fa-map-marker-alt" style="font-size: 2rem; color: #3498db;"></i><span style="margin-left: 10px;">Carte de suivi GPS</span></div>';
    
    // D√©finir le bouton pause/d√©marrer
    document.getElementById('pause-btn').onclick = startRun;
    
    // D√©marrer le stockage p√©riodique des donn√©es
    setTimeout(storeRunDataPeriodically, 10000);

    // Afficher l'historique et les statistiques existants
    updateHistory();

    // Onboarding
    const onboardingOverlay = document.getElementById('onboarding-overlay');
    const onboardingSteps = onboardingOverlay.querySelectorAll('.onboarding-step');
    function showOnboardingStep(i) {
        onboardingSteps.forEach((step, idx) => {
            step.classList.toggle('active', idx === i);
        });
    }
    document.getElementById('onboard-next-1').onclick = () => {
        const name = document.getElementById('onboard-name').value.trim();
        if (name) {
            userData.firstName = name;
        }
        showOnboardingStep(1);
    };
    document.getElementById('onboard-next-2').onclick = () => showOnboardingStep(2);
    document.getElementById('onboard-next-3').onclick = () => showOnboardingStep(3);
    document.getElementById('onboard-create').onclick = () => {
        onboardingOverlay.classList.remove('active');
        localStorage.setItem('onboardingCompleted', '1');
        localStorage.setItem('runPacerUserData', JSON.stringify(userData));
        document.getElementById('nav-create-plan').click();
    };
    document.getElementById('onboard-skip').onclick = () => {
        onboardingOverlay.classList.remove('active');
        localStorage.setItem('onboardingCompleted', '1');
        localStorage.setItem('runPacerUserData', JSON.stringify(userData));
    };
    if (!localStorage.getItem('onboardingCompleted')) {
        onboardingOverlay.classList.add('active');
        showOnboardingStep(0);
    }
});

        // Service Worker pour la fonctionnalit√© PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('service-worker.js')
                    .then(function(registration) {
                        console.log('ServiceWorker enregistr√© avec succ√®s:', registration.scope);
                    })
                    .catch(function(error) {
                        console.log('√âchec de l\'enregistrement du ServiceWorker:', error);
                    });
            });
        }
        
        // V√©rifier la disponibilit√© du GPS
        if ('geolocation' in navigator) {
            console.log("G√©olocalisation disponible");
        } else {
            console.log("G√©olocalisation non disponible");
            alert("Votre appareil ne prend pas en charge la g√©olocalisation. Certaines fonctionnalit√©s ne seront pas disponibles.");
        }

        function generateGPX(run) {
            if (!run.gpsData || run.gpsData.length < 2) return null;

            let gpxContent = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="RunPacer App" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>RunPacer - Course du ${run.date}</name>
    <time>${new Date(run.startTime || run.date).toISOString()}</time>
  </metadata>
  <trk>
    <name>Course ${run.type} - ${run.distance}km</name>
    <trkseg>`;

            run.gpsData.forEach(point => {
                gpxContent += `
      <trkpt lat="${point.latitude}" lon="${point.longitude}">
        <ele>${point.altitude || 0}</ele>
        <time>${new Date(point.timestamp).toISOString()}</time>
      </trkpt>`;
            });

            gpxContent += `
    </trkseg>
  </trk>
</gpx>`;

            return gpxContent;
        }

        // Exporter la course au format GPX
        function exportToGPX(run) {
            const gpxContent = generateGPX(run);
            if (!gpxContent) {
                alert("Pas de donn√©es GPS disponibles pour cette course");
                return;
            }
            
            // Cr√©er un Blob et un lien de t√©l√©chargement
            const blob = new Blob([gpxContent], { type: 'application/gpx+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `runpacer-${run.date}-${run.distance}km.gpx`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Partager la course
        function shareRun(run) {
            if (navigator.share) {
                // Utiliser Web Share API si disponible
                navigator.share({
                    title: `Ma course RunPacer - ${run.distance}km`,
                    text: `J'ai couru ${run.distance}km en ${formatTime(run.duration)} (rythme: ${run.pace}/km) avec RunPacer!`,
                    // url: window.location.href  // On pourrait ajouter une URL si l'app est h√©berg√©e
                })
                .catch(error => {
                    console.log('Erreur lors du partage:', error);
                    alert("Impossible de partager: " + error.message);
                });
            } else {
                // Fallback si Web Share API n'est pas disponible
                const shareText = `J'ai couru ${run.distance}km en ${formatTime(run.duration)} (rythme: ${run.pace}/km) avec RunPacer!`;
                alert("Fonction de partage non disponible. Voici le texte √† partager:\n\n" + shareText);
            }
        }

        function connectStrava() {
            const url = `https://www.strava.com/oauth/authorize?client_id=${STRAVA_CLIENT_ID}&response_type=code&redirect_uri=${encodeURIComponent(STRAVA_REDIRECT_URI)}&scope=activity:write&approval_prompt=auto`;
            window.location.href = url;
        }

        async function exchangeStravaCode(code) {
            const params = new URLSearchParams();
            params.append('client_id', STRAVA_CLIENT_ID);
            params.append('client_secret', STRAVA_CLIENT_SECRET);
            params.append('code', code);
            params.append('grant_type', 'authorization_code');
            const resp = await fetch('https://www.strava.com/oauth/token', {
                method: 'POST',
                body: params
            });
            const data = await resp.json();
            if (!resp.ok) throw new Error(data.message || 'Erreur');
            userData.stravaToken = data.access_token;
            userData.stravaRefreshToken = data.refresh_token;
            userData.stravaExpiresAt = data.expires_at;
            localStorage.setItem('runPacerUserData', JSON.stringify(userData));
            document.getElementById('strava-status').textContent = 'Connect√©';
        }

        async function ensureStravaToken() {
            if (!userData.stravaToken) return false;
            const now = Math.floor(Date.now() / 1000);
            if (userData.stravaExpiresAt && now >= userData.stravaExpiresAt - 60) {
                const params = new URLSearchParams();
                params.append('client_id', STRAVA_CLIENT_ID);
                params.append('client_secret', STRAVA_CLIENT_SECRET);
                params.append('grant_type', 'refresh_token');
                params.append('refresh_token', userData.stravaRefreshToken);
                const resp = await fetch('https://www.strava.com/oauth/token', {
                    method: 'POST',
                    body: params
                });
                const data = await resp.json();
                if (!resp.ok) throw new Error(data.message || 'Erreur');
                userData.stravaToken = data.access_token;
                userData.stravaRefreshToken = data.refresh_token;
                userData.stravaExpiresAt = data.expires_at;
                localStorage.setItem('runPacerUserData', JSON.stringify(userData));
            }
            return true;
        }

        async function publishToStrava(run) {
            if (!userData.stravaToken) {
                alert("Connectez votre compte Strava dans le profil");
                return;
            }

            try {
                await ensureStravaToken();
                const token = userData.stravaToken;
                if (run.gpsData && run.gpsData.length >= 2) {
                    const gpxContent = generateGPX(run);
                    const formData = new FormData();
                    formData.append('file', new Blob([gpxContent], { type: 'application/gpx+xml' }), 'run.gpx');
                    formData.append('data_type', 'gpx');
                    formData.append('name', `RunPacer ${run.distance}km`);
                    formData.append('description', `Rythme ${run.pace}/km via RunPacer`);
                    formData.append('activity_type', 'run');

                    const resp = await fetch('https://www.strava.com/api/v3/uploads', {
                        method: 'POST',
                        headers: { 'Authorization': 'Bearer ' + token },
                        body: formData
                    });
                    const data = await resp.json();
                    if (!resp.ok) throw new Error(data.message || 'Erreur');
                    alert('Course envoy√©e sur Strava. Elle appara√Ætra une fois trait√©e.');
                } else {
                    const params = new URLSearchParams();
                    params.append('name', `RunPacer ${run.distance}km`);
                    params.append('type', 'Run');
                    const startLocal = run.startTime || (run.date + 'T00:00:00');
                    params.append('start_date_local', startLocal);
                    params.append('elapsed_time', Math.round(run.duration));
                    params.append('description', `Rythme ${run.pace}/km via RunPacer`);
                    params.append('distance', Math.round(parseFloat(run.distance) * 1000));
                    const resp = await fetch('https://www.strava.com/api/v3/activities', {
                        method: 'POST',
                        headers: {
                            'Authorization': 'Bearer ' + token,
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: params.toString()
                    });
                    const data = await resp.json();
                    if (!resp.ok) throw new Error(data.message || 'Erreur');
                    alert('Course ajout√©e sur Strava.');
                }
            } catch (err) {
                alert('Erreur Strava: ' + err.message);
            }
        }

        // Disparition de l'√©cran d'accueil apr√®s chargement
        window.addEventListener('load', function() {
            const splash = document.getElementById('splash-screen');
            if (splash) {
                setTimeout(() => {
                    splash.classList.add('fade-out');
                    setTimeout(() => splash.remove(), 600);
                }, 1500);
            }
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('portrait').catch(() => {});
            }
        });
    </script>
    <footer><a href="PRIVACY.md">Politique de confidentialite</a></footer>
</body>
</html>
