<!DOCTYPE html>
<html lang="fr">
<head>
    <!-- Leaflet CSS et JS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <!-- Chart.js pour les graphiques -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- html2canvas pour capturer la carte -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <!-- Fonctions utilitaires communes -->
    <script src="utils.js"></script>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RunPacer - Votre Coach de Course</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css">
    <link rel="manifest" href="manifest.json">
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --warning-color: #e74c3c;
            --dark-color: #2c3e50;
            --light-color: #ecf0f1;
            --spacing: 16px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: var(--dark-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        header {
            background-color: var(--primary-color);
            color: white;
            padding: var(--spacing);
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        nav {
            display: flex;
            justify-content: space-around;
            background-color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        nav button {
            border: none;
            background: none;
            padding: var(--spacing);
            flex: 1;
            cursor: pointer;
            color: var(--dark-color);
            border-bottom: 3px solid transparent;
        }
        
        nav button.active {
            border-bottom: 3px solid var(--primary-color);
            color: var(--primary-color);
            font-weight: bold;
        }
        
        .container {
            flex: 1;
            padding: var(--spacing);
            max-width: 800px;
            margin: 0 auto;
            width: 100%;
        }
        
        .section {
            display: none;
            animation: fadeIn 0.3s;
        }
        
        .section.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .card {
            background-color: white;
            border-radius: 8px;
            padding: var(--spacing);
            margin-bottom: var(--spacing);
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .card-title {
            font-size: 1.2rem;
            margin-bottom: 8px;
            color: var(--primary-color);
        }
        
        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            display: inline-flex;
            align-items: center;
        }
        
        .btn i {
            margin-right: 8px;
        }
        
        .btn-lg {
            padding: 14px 20px;
            font-size: 1.1rem;
        }
        
        .btn-warning {
            background-color: var(--warning-color);
        }
        
        .btn-success {
            background-color: var(--secondary-color);
        }
        
        .run-controls {
            display: flex;
            justify-content: space-around;
            margin-top: var(--spacing);
        }
        
        .big-metric {
            font-size: 3rem;
            font-weight: bold;
            text-align: center;
            margin: 16px 0;
        }
        
        .big-metric-label {
            text-align: center;
            color: #95a5a6;
            margin-bottom: var(--spacing);
        }
        
        .metrics-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--spacing);
        }
        
        .metric-box {
            flex: 1;
            text-align: center;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            margin: 0 4px;
        }
        
        .metric-box-value {
            font-size: 1.4rem;
            font-weight: bold;
        }
        
        .metric-box-label {
            font-size: 0.8rem;
            color: #95a5a6;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--spacing);
            margin-bottom: var(--spacing);
        }
        
        .stat-item {
            background-color: white;
            padding: var(--spacing);
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .table th, .table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        .table th {
            color: var(--primary-color);
        }
        
        .too-fast {
            color: #e74c3c;
        }
        
        .good-pace {
            color: #2ecc71;
        }
        
        .too-slow {
            color: #f39c12;
        }
        
        .voice-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .hidden {
            display: none;
        }
        
        #map {
            height: 300px;
            margin-bottom: var(--spacing);
            border-radius: 8px;
            overflow: hidden;
        }
        
        #run-map {
            height: 200px;
            margin-bottom: var(--spacing);
            border-radius: 8px;
            overflow: hidden;
        }
        
        /* Formulaire profil */
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: bold;
        }
        
        .form-control {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }
        
        .form-hint {
            font-size: 0.8rem;
            color: #7f8c8d;
            margin-top: 4px;
        }
        
        /* Modal pour voir les détails d'une course */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background-color: white;
            padding: var(--spacing);
            border-radius: 8px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            width: 600px;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing);
        }
        
        .modal-title {
            font-size: 1.5rem;
            color: var(--primary-color);
        }
        
        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        /* Sélecteur de type de course */
        .run-type-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: var(--spacing);
        }
        
        .run-type {
            flex: 1;
            min-width: 120px;
        }
        
        .run-type input[type="radio"] {
            display: none;
        }
        
        .run-type label {
            display: block;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .run-type input[type="radio"]:checked + label {
            background-color: var(--primary-color);
            color: white;
        }
        
        /* Amélioration de l'affichage des cartes */
        .map-container {
            position: relative;
            margin-bottom: var(--spacing);
        }
        
        .map-stats {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(255,255,255,0.9);
            padding: 8px;
            border-radius: 4px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        /* Styles pour la page de détail des courses */
        .map-icon {
            background: none !important;
            border: none;
        }

        .km-marker {
            background: none !important;
            border: none;
        }

        /* Animation pour les transitions de page */
        .section {
            transition: opacity 0.3s ease;
        }

        /* Styles pour le graphique d'allure */
        .pace-chart-bar {
            transition: height 0.5s ease;
        }

        /* Styles pour les courses dans la liste d'historique */
        #history-table tr {
            transition: background-color 0.2s ease;
        }

        #history-table tr:hover {
            background-color: rgba(52, 152, 219, 0.1);
        }

/* Styles pour la création de plan */
.days-selection {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 8px;
    margin-top: 8px;
}

.days-selection div {
    display: flex;
    align-items: center;
}

#plan-summary {
    margin-bottom: 16px;
    padding: 12px;
    background-color: #f8f9fa;
    border-radius: 4px;
}

#plan-summary h3 {
    color: var(--primary-color);
    margin-bottom: 8px;
}

#generated-plan-table th {
    white-space: nowrap;
}

        .selected-session {
    background-color: rgba(52, 152, 219, 0.2) !important;
    border-left: 3px solid var(--primary-color);
}

#full-plan-table tr.selected-session td {
    font-weight: bold;
}

        #full-plan-table tr:not(:first-child):hover {
    background-color: rgba(52, 152, 219, 0.1);
    transition: background-color 0.2s ease;
}
        
        /* Styles pour les statistiques d'élévation */
        .elevation-chart {
            width: 100%;
            height: 100px;
            background: linear-gradient(to bottom, #ecf0f1 0%, #ecf0f1 70%, #3498db 70%, #3498db 100%);
            position: relative;
            overflow: hidden;
            border-radius: 4px;
            margin-top: 10px;
        }

        .elevation-point {
            position: absolute;
            bottom: 0;
            width: 2px;
            background-color: rgba(52, 152, 219, 0.3);
        }

        /* Indicateur de qualité GPS */
        .gps-quality {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            font-size: 1.2rem;
        }

        .gps-good {
            background-color: var(--secondary-color);
            color: white;
        }

        .gps-medium {
            background-color: #f39c12;
            color: white;
        }

        .gps-poor {
            background-color: var(--warning-color);
            color: white;
        }

        /* Animation de chargement pour les cartes */
        .map-loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* Styles pour l'image du tracé */
        .route-image {
            width: 100%;
            height: 200px;
            border-radius: 8px;
            object-fit: cover;
            margin-bottom: var(--spacing);
            border: 1px solid #eee;
        }

        /* Section détails de course */
        #run-detail-section {
            display: none;
        }

        #run-detail-section.active {
            display: block;
        }
    </style>
</head>
<body>
    <header>
        <h1>RunPacer</h1>
        <p id="header-objective">Atteignez votre objectif de 4:00 min/km</p>
    </header>
    
    <nav>
        <button id="nav-plan" class="active"><i class="fas fa-calendar-alt"></i> Plan</button>
        <button id="nav-run"><i class="fas fa-running"></i> Courir</button>
        <button id="nav-stats"><i class="fas fa-chart-line"></i> Stats</button>
        <button id="nav-profile"><i class="fas fa-user"></i> Profil</button>
        <button id="nav-create-plan"><i class="fas fa-calendar-plus"></i> Créer plan</button>
    </nav>
    
    <div class="container">
        <!-- Section Plan d'entraînement -->
        <div id="plan-section" class="section active">
            <div class="card">
                <div class="card-title">Votre objectif</div>
                <p id="goal-event">Course 10km: <strong>7 juin 2025</strong></p>
                <p id="goal-pace">Objectif rythme: <strong>4:00 min/km</strong></p>
                <p id="current-level">Niveau actuel: <strong>4:36 min/km</strong></p>
                <p id="training-days">Jours d'entraînement: <strong>Mardi, Jeudi, Dimanche</strong></p>
            </div>
            
            <div class="card">
                <div class="card-title">Prochaine séance</div>
                <div id="next-session-details">
                    <h3 id="next-session-title">Mardi - Course facile</h3>
                    <p>Distance: <strong id="next-session-distance">5 km</strong></p>
                    <p>Rythme cible: <strong id="next-session-pace">5:00 min/km</strong></p>
                    <p id="next-session-goal">Objectif: Récupération active, travail cardiovasculaire léger</p>
                    <button class="btn" id="start-run-btn"><i class="fas fa-play"></i> Commencer la séance</button>
                </div>
            </div>
            
            <div class="card">
                <div class="card-title">Programme complet</div>
                <div id="full-plan-container">
                    <table class="table" id="full-plan-table">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Type</th>
                                <th>Distance</th>
                                <th>Rythme</th>
                                <th>Terminé</th>
                            </tr>
                        </thead>
                        <tbody id="full-plan-body">
                            <!-- Le plan complet sera généré ici -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <!-- Section Course active -->
        <div id="run-section" class="section">
            <div class="card">
                <div class="card-title">Type de course</div>
                <div class="run-type-selector" id="run-type-selector">
                    <div class="run-type">
                        <input type="radio" id="easy-run" name="run-type" value="easy" checked>
                        <label for="easy-run"><i class="fas fa-walking"></i> Course facile</label>
                    </div>
                    <div class="run-type">
                        <input type="radio" id="interval-run" name="run-type" value="interval">
                        <label for="interval-run"><i class="fas fa-tachometer-alt"></i> Intervalles</label>
                    </div>
                    <div class="run-type">
                        <input type="radio" id="long-run" name="run-type" value="long">
                        <label for="long-run"><i class="fas fa-road"></i> Longue sortie</label>
                    </div>
                    <div class="run-type">
                        <input type="radio" id="tempo-run" name="run-type" value="tempo">
                        <label for="tempo-run"><i class="fas fa-fire"></i> Course tempo</label>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <div class="big-metric-label">Rythme actuel</div>
                <div class="big-metric" id="current-pace">--:--</div>
                <div id="pace-feedback" class="good-pace">Prêt à commencer</div>
            </div>

            <div id="interval-indicator" class="hidden" style="text-align: center; margin: 10px 0; font-weight: bold;">
    <span id="interval-phase">Intervalle rapide</span>
    <span id="interval-distance" style="display: block; font-size: 0.8em;"></span>
</div>
            
            <div class="metrics-row">
                <div class="metric-box">
                    <div class="metric-box-value" id="distance">0.00</div>
                    <div class="metric-box-label">KM</div>
                </div>
                <div class="metric-box">
                    <div class="metric-box-value" id="duration">00:00</div>
                    <div class="metric-box-label">TEMPS</div>
                </div>
                <div class="metric-box">
                    <div class="metric-box-value" id="target-pace">--:--</div>
                    <div class="metric-box-label">OBJECTIF</div>
                </div>
            </div>
            
            <div id="map">
                <!-- La carte sera chargée ici -->
            </div>
            
            <div class="run-controls">
                <button class="btn btn-lg" id="pause-btn"><i class="fas fa-play"></i> Démarrer</button>
                <button class="btn btn-lg btn-warning" id="stop-btn" disabled><i class="fas fa-stop"></i> Arrêter</button>
            </div>
            
            <div class="voice-indicator hidden" id="voice-indicator">
                <i class="fas fa-volume-up"></i>
            </div>
        </div>
        
        <!-- Section Statistiques -->
        <div id="stats-section" class="section">
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="total-runs">0</div>
                    <div>Courses effectuées</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="best-pace">--:--</div>
                    <div>Meilleur rythme</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="total-distance">0</div>
                    <div>Distance totale (km)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="avg-pace">--:--</div>
                    <div>Rythme moyen</div>
                </div>
            </div>
            
            <div class="card">
                <div class="card-title">Progression du rythme</div>
                <canvas id="pace-chart" width="400" height="200"></canvas>
            </div>
            
            <div class="card">
                <div class="card-title">Historique des courses</div>
                <table class="table">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Type</th>
                            <th>Distance</th>
                            <th>Rythme</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="history-table">
                        <!-- L'historique sera rempli dynamiquement -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- Section Profil -->
        <div id="profile-section" class="section">
            <div class="card">
                <div class="card-title">Mes informations</div>
                <form id="profile-form">
                    <div class="form-group">
                        <label for="current-pace-input">Rythme actuel</label>
                        <input type="text" class="form-control" id="current-pace-input" value="4:36" placeholder="min:sec">
                        <div class="form-hint">Votre rythme actuel sur 10km</div>
                    </div>
                    
                    <div class="form-group">
                        <label for="target-pace-input">Rythme objectif</label>
                        <input type="text" class="form-control" id="target-pace-input" value="4:00" placeholder="min:sec">
                        <div class="form-hint">Votre objectif de rythme pour votre prochaine course</div>
                    </div>
                    
                    <div class="form-group">
                        <label for="event-date-input">Date de l'événement</label>
                        <input type="date" class="form-control" id="event-date-input" value="2025-06-07">
                    </div>
                    
                    <div class="form-group">
                        <label>Jours d'entraînement préférés</label>
                        <div>
                            <input type="checkbox" id="monday" name="training-days">
                            <label for="monday">Lundi</label>
                        </div>
                        <div>
                            <input type="checkbox" id="tuesday" name="training-days" checked>
                            <label for="tuesday">Mardi</label>
                        </div>
                        <div>
                            <input type="checkbox" id="wednesday" name="training-days">
                            <label for="wednesday">Mercredi</label>
                        </div>
                        <div>
                            <input type="checkbox" id="thursday" name="training-days" checked>
                            <label for="thursday">Jeudi</label>
                        </div>
                        <div>
                            <input type="checkbox" id="friday" name="training-days">
                            <label for="friday">Vendredi</label>
                        </div>
                        <div>
                            <input type="checkbox" id="saturday" name="training-days">
                            <label for="saturday">Samedi</label>
                        </div>
                        <div>
                            <input type="checkbox" id="sunday" name="training-days" checked>
                            <label for="sunday">Dimanche</label>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="voice-enabled">Instructions vocales</label>
                        <div>
                            <input type="checkbox" id="voice-enabled" checked>
                            <label for="voice-enabled">Activer les instructions vocales</label>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="strava-token-input">Token d'accès Strava</label>
                        <input type="text" class="form-control" id="strava-token-input" placeholder="OAuth token">
                        <div class="form-hint">Générez un token depuis votre compte Strava</div>
                    </div>
                    
                    <button type="submit" class="btn btn-success">Enregistrer les modifications</button>
                </form>
            </div>
        </div>

        <!-- Section Création de plan -->
<div id="create-plan-section" class="section">
    <div class="card">
        <div class="card-title">Créer un plan d'entraînement</div>
        <form id="plan-form">
            <div class="form-group">
                <label for="plan-distance">Distance de course cible</label>
                <select class="form-control" id="plan-distance">
                    <option value="5">5 km</option>
                    <option value="10" selected>10 km</option>
                    <option value="21.1">Semi-marathon (21.1 km)</option>
                    <option value="42.2">Marathon (42.2 km)</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="plan-event-date">Date de la course</label>
                <input type="date" class="form-control" id="plan-event-date" min="">
            </div>
            
            <div class="form-group">
                <label for="plan-current-time">Votre temps actuel pour 10 km (hh:mm:ss)</label>
                <input type="text" class="form-control" id="plan-current-time" placeholder="00:50:00">
            </div>
            
            <div class="form-group">
                <label for="plan-target-time">Temps objectif pour 10 km (hh:mm:ss)</label>
                <input type="text" class="form-control" id="plan-target-time" placeholder="00:45:00">
            </div>
            
            <div class="form-group">
                <label for="plan-sessions">Nombre de séances par semaine</label>
                <select class="form-control" id="plan-sessions">
                    <option value="3">3 séances</option>
                    <option value="4" selected>4 séances</option>
                    <option value="5">5 séances</option>
                </select>
            </div>
            
            <div class="form-group">
                <label>Jours d'entraînement préférés</label>
                <div class="days-selection">
                    <input type="checkbox" id="plan-monday" name="plan-training-days">
                    <label for="plan-monday">Lundi</label>
                    
                    <input type="checkbox" id="plan-tuesday" name="plan-training-days" checked>
                    <label for="plan-tuesday">Mardi</label>
                    
                    <input type="checkbox" id="plan-wednesday" name="plan-training-days">
                    <label for="plan-wednesday">Mercredi</label>
                    
                    <input type="checkbox" id="plan-thursday" name="plan-training-days" checked>
                    <label for="plan-thursday">Jeudi</label>
                    
                    <input type="checkbox" id="plan-friday" name="plan-training-days">
                    <label for="plan-friday">Vendredi</label>
                    
                    <input type="checkbox" id="plan-saturday" name="plan-training-days">
                    <label for="plan-saturday">Samedi</label>
                    
                    <input type="checkbox" id="plan-sunday" name="plan-training-days" checked>
                    <label for="plan-sunday">Dimanche</label>
                </div>
            </div>
            
            <button type="submit" class="btn btn-success">Générer le plan</button>
        </form>
    </div>
    
    <div class="card" id="generated-plan-card" style="display: none;">
        <div class="card-title">Plan généré</div>
        <div id="plan-summary"></div>
        <table class="table" id="generated-plan-table">
            <thead>
                <tr>
                    <th>Semaine</th>
                    <th>Date</th>
                    <th>Type</th>
                    <th>Distance</th>
                    <th>Rythme</th>
                    <th>Objectif</th>
                </tr>
            </thead>
            <tbody id="generated-plan-body">
                <!-- Le plan généré sera affiché ici -->
            </tbody>
        </table>
        <button class="btn" id="save-plan-btn"><i class="fas fa-save"></i> Sauvegarder ce plan</button>
    </div>
</div>
        
        <!-- Section Détails de course -->
        <div id="run-detail-section" class="section">
            <div class="card">
                <div class="card-title">Détails de la course</div>
                <div class="big-metric-label" id="run-date">12 avril 2025</div>
                <div class="metrics-row">
                    <div class="metric-box">
                        <div class="metric-box-value" id="run-detail-distance">5.2</div>
                        <div class="metric-box-label">KM</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-box-value" id="run-detail-duration">25:12</div>
                        <div class="metric-box-label">TEMPS</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-box-value" id="run-detail-pace">4:50</div>
                        <div class="metric-box-label">RYTHME</div>
                    </div>
                </div>
                
                <!-- Image du tracé de la course -->
                <div class="card-title">Tracé de votre course</div>
                <img id="route-image" class="route-image" src="" alt="Tracé de la course">
                
                <div class="metrics-row">
                    <div class="metric-box">
                        <div class="metric-box-value" id="run-detail-elevation">42</div>
                        <div class="metric-box-label">D+ (m)</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-box-value" id="run-detail-best-pace">4:20</div>
                        <div class="metric-box-label">MEILLEUR KM</div>
                    </div>
                </div>
                
                <div class="card-title">Détails par kilomètre</div>
                <table class="table">
                    <thead>
                        <tr>
                            <th>KM</th>
                            <th>Temps</th>
                            <th>Rythme</th>
                        </tr>
                    </thead>
                    <tbody id="run-splits">
                        <!-- Les splits seront ajoutés ici -->
                    </tbody>
                </table>
            </div>
            
            <div class="run-controls">
                <button class="btn" id="share-run-btn"><i class="fas fa-share-alt"></i> Partager</button>
                <button class="btn" id="export-gpx-btn"><i class="fas fa-file-export"></i> Exporter GPX</button>
                <button class="btn" id="strava-upload-btn"><i class="fab fa-strava"></i> Strava</button>
                <button class="btn" id="back-to-stats-btn"><i class="fas fa-arrow-left"></i> Retour</button>
            </div>
        </div>
    </div>

    <!-- Modal pour voir les détails d'une course -->
    <div class="modal" id="run-details-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="modal-run-title">Détails de la course</h3>
                <button class="close-modal">&times;</button>
            </div>
            <div id="modal-run-content">
                <div class="map-container">
                    <div id="run-map"></div>
                    <div class="map-stats">
                        <div>Distance: <strong id="modal-distance">0.00 km</strong></div>
                        <div>Durée: <strong id="modal-duration">00:00</strong></div>
                        <div>Rythme: <strong id="modal-pace">--:-- min/km</strong></div>
                    </div>
                </div>
                
                <div class="metrics-row">
                    <div class="metric-box">
                        <div class="metric-box-value" id="modal-avg-pace">--:--</div>
                        <div class="metric-box-label">RYTHME MOYEN</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-box-value" id="modal-max-pace">--:--</div>
                        <div class="metric-box-label">MAX</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-box-value" id="modal-min-pace">--:--</div>
                        <div class="metric-box-label">MIN</div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-title">Détails par kilomètre</div>
                    <table class="table">
                        <thead>
                            <tr>
                                <th>KM</th>
                                <th>Temps</th>
                                <th>Rythme</th>
                            </tr>
                        </thead>
                        <tbody id="modal-splits">
                            <!-- Les splits seront ajoutés ici -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration initiale
        const userData = {
    currentPace: "4:36", // minutes:secondes par km
    targetPace: "4:00",
    eventDate: "2025-06-07",
    trainingDays: ["tuesday", "thursday", "sunday"],
    voiceEnabled: true,
    stravaToken: "",
    runs: [], // Historique des courses
    trainingPlan: [], // Plan d'entraînement généré
    customPlan: null // Stockera le plan personnalisé généré
};

        // Variables pour le suivi en arrière-plan
let isBackgroundRun = false;
let backgroundRunInterval;
        
        // Variables pour le suivi de course
        let isRunning = false;
        let runInterval;
        let currentDuration = 0;
        let distanceTraveled = 0;
        let locationData = [];
        let previousLocation = null;
        let watchId;
        let isTrackingLocation = false;
        let mapObject;
        let runMapObject;
        let lastSpokenTime = 0;
        let currentRunType = "easy";
        let kmSplits = [];
        let currentKmStartTime = 0;
        let currentKmStartDistance = 0;
        let currentRouteImage = null;
        // Ajouter ces variables en haut avec les autres :
let intervalPhase = 'work'; // 'work' ou 'recovery'
let intervalDistanceRemaining = 0;
let currentTargetPace = "5:00"; // Valeur par défaut
        
       
const runTypes = {
    easy: {
        name: "Course facile",
        description: "Récupération active, travail cardiovasculaire léger",
        paceOffset: 1.0, // +1 min/km par rapport au rythme actuel
        distance: 5,
        isInterval: false
    },
    interval: {
        name: "Intervalles",
        description: "Alternance de courses rapides et de récupération",
        paceOffset: -0.25, // -15 sec/km pour les portions rapides
        recoveryPaceOffset: 1.5, // +1:30 min/km pour la récupération
        distance: 6,
        intervalDuration: 400, // durée de chaque intervalle en mètres
        recoveryDuration: 200, // durée de récupération en mètres
        isInterval: true
    },
    long: {
        name: "Longue sortie",
        description: "Développement de l'endurance fondamentale",
        paceOffset: 0.75, // +45 sec/km par rapport au rythme actuel
        distance: 8,
        isInterval: false
    },
    tempo: {
        name: "Course tempo",
        description: "Allure soutenue proche du seuil anaérobie",
        paceOffset: -0.5, // -30 sec/km par rapport au rythme actuel
        distance: 5,
        isInterval: false
    }
};
        
        // Conversion de pace (min:sec) en secondes
        function paceToSeconds(pace) {
            const parts = pace.split(':');
            return parseInt(parts[0]) * 60 + parseInt(parts[1]);
        }
        
        // Conversion de secondes en pace (min:sec)
        function secondsToPace(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Convertir un rythme "mm:ss" en texte lisible pour la synthèse vocale
        function paceToSpeech(pace) {
            const [mins, secs] = pace.split(':').map(Number);
            const minuteWord = mins > 1 ? 'minutes' : 'minute';
            let result = `${mins} ${minuteWord}`;
            if (secs > 0) {
                result += ` ${secs}`;
            }
            return result;
        }

        // Formater le temps en hh:mm:ss
        function formatTime(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            if (hours > 0) {
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else {
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }
        
    

// Fonction pour générer un plan personnalisé
function generateCustomPlan() {
    // Récupérer les valeurs du formulaire
    const distance = parseFloat(document.getElementById('plan-distance').value);
    const eventDate = new Date(document.getElementById('plan-event-date').value);
    const currentTime = document.getElementById('plan-current-time').value;
    const targetTime = document.getElementById('plan-target-time').value;
    const sessionsPerWeek = parseInt(document.getElementById('plan-sessions').value);
    
    // Récupérer les jours sélectionnés
    const selectedDays = [];
    const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
    days.forEach(day => {
        if (document.getElementById(`plan-${day}`).checked) {
            selectedDays.push(day);
        }
    });
    
    // Validation des entrées
    if (!eventDate || isNaN(eventDate.getTime())) {
        alert("Veuillez sélectionner une date valide");
        return;
    }
    
    if (!isValidTimeFormat(currentTime) || !isValidTimeFormat(targetTime)) {
        alert("Veuillez entrer des temps valides au format hh:mm:ss");
        return;
    }
    
    if (selectedDays.length === 0) {
        alert("Veuillez sélectionner au moins un jour d'entraînement");
        return;
    }
    
    if (selectedDays.length < sessionsPerWeek) {
        alert(`Vous avez sélectionné ${selectedDays.length} jours mais demandé ${sessionsPerWeek} séances par semaine.`);
        return;
    }
    
    // Convertir les temps en secondes
    const currentTimeSec = timeToSeconds(currentTime);
    const targetTimeSec = timeToSeconds(targetTime);
    
    // Calculer les rythmes actuels et cibles (en secondes/km)
    const currentPaceSec = currentTimeSec / 10; // pour 10km
    const targetPaceSec = targetTimeSec / 10; // pour 10km
    
    // Calculer la durée totale du plan en semaines
    const today = new Date();
    const weeksDiff = Math.ceil((eventDate - today) / (1000 * 60 * 60 * 24 * 7));
    
    if (weeksDiff <= 0) {
        alert("La date de la course doit être dans le futur");
        return;
    }
    
    // Créer le plan
    const plan = [];
    const progressPerWeek = (targetPaceSec - currentPaceSec) / weeksDiff;
    
    // Générer les semaines d'entraînement
    for (let week = 1; week <= weeksDiff; week++) {
        const weekStartDate = new Date(today);
        weekStartDate.setDate(today.getDate() + ((week - 1) * 7));
        
        // Calculer le rythme cible pour cette semaine
        const weekTargetPaceSec = currentPaceSec + (progressPerWeek * (week - 1));
        
        // Sélectionner aléatoirement les jours d'entraînement pour cette semaine
        const shuffledDays = [...selectedDays].sort(() => 0.5 - Math.random());
        const weekDays = shuffledDays.slice(0, sessionsPerWeek).sort();
        
        // Générer les séances pour chaque jour sélectionné
        weekDays.forEach(day => {
            const dayIndex = days.indexOf(day);
            const sessionDate = new Date(weekStartDate);
            sessionDate.setDate(weekStartDate.getDate() + dayIndex);
            
            // Déterminer le type de séance
            let type, sessionDistance, sessionPaceSec;
            
            // En fonction de la semaine et du jour
            if (week === weeksDiff) {
                // Semaine de la course - séance légère
                type = 'easy';
                sessionDistance = distance * 0.5;
                sessionPaceSec = weekTargetPaceSec + 60; // +1 min/km
            } else if (day === 'tuesday' || day === 'wednesday' || day === 'thursday') {
                // Jour de semaine - séance de qualité
                type = Math.random() > 0.5 ? 'interval' : 'tempo';
                
                if (type === 'interval') {
                    sessionDistance = 6 + (week * 0.2); // Augmente légèrement chaque semaine
                    sessionPaceSec = weekTargetPaceSec - (15 * (week / weeksDiff)); // Plus rapide que la cible
                } else {
                    sessionDistance = 5 + (week * 0.1);
                    sessionPaceSec = weekTargetPaceSec - (30 * (week / weeksDiff));
                }
            } else {
                // Week-end - longue sortie ou course facile
                if (day === 'saturday' || day === 'sunday') {
                    type = 'long';
                    sessionDistance = 8 + (week * 0.5); // Augmente progressivement
                    sessionPaceSec = weekTargetPaceSec + 45; // +45 sec/km
                } else {
                    type = 'easy';
                    sessionDistance = 5 + (week * 0.1);
                    sessionPaceSec = weekTargetPaceSec + 60; // +1 min/km
                }
            }
            
            // Ajuster pour la distance cible
            if (distance === 5) {
                sessionDistance = Math.min(sessionDistance, 5);
            } else if (distance === 21.1) {
                // Pour semi-marathon
                if (type === 'long') {
                    sessionDistance = Math.min(8 + (week * 1.5), 18);
                }
            } else if (distance === 42.2) {
                // Pour marathon
                if (type === 'long') {
                    sessionDistance = Math.min(10 + (week * 2), 32);
                }
            }
            
            // Arrondir les valeurs
            sessionDistance = Math.round(sessionDistance * 2) / 2; // Arrondir au 0.5 km près
            
            // Ajouter la séance au plan
            plan.push({
                week: week,
                date: sessionDate.toISOString().split('T')[0],
                day: day,
                type: type,
                typeName: runTypes[type].name,
                distance: sessionDistance,
                pace: secondsToPace(sessionPaceSec),
                goal: runTypes[type].description,
                completed: false
            });
        });
    }
    
    // Afficher le plan généré
    displayGeneratedPlan(plan, distance, eventDate, currentTime, targetTime);
}

// Afficher le plan généré
function displayGeneratedPlan(plan, distance, eventDate, currentTime, targetTime) {
    const tbody = document.getElementById('generated-plan-body');
    tbody.innerHTML = '';
    
    let currentWeek = 0;
    
    plan.forEach(session => {
        if (session.week !== currentWeek) {
            // Ajouter une ligne de séparation pour la nouvelle semaine
            const weekRow = document.createElement('tr');
            weekRow.className = 'week-separator';
            weekRow.innerHTML = `<td colspan="6" style="background-color: #f8f9fa; font-weight: bold;">Semaine ${session.week}</td>`;
            tbody.appendChild(weekRow);
            currentWeek = session.week;
        }
        
        const tr = document.createElement('tr');
        const date = new Date(session.date);
        const formattedDate = date.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' });
        
        tr.innerHTML = `
            <td>${session.week}</td>
            <td>${formattedDate} (${session.day.charAt(0).toUpperCase() + session.day.slice(1)})</td>
            <td>${session.typeName}</td>
            <td>${session.distance} km</td>
            <td>${session.pace} min/km</td>
            <td>${session.goal}</td>
        `;
        
        tbody.appendChild(tr);
    });
    
    // Mettre à jour le résumé
    const formattedEventDate = eventDate.toLocaleDateString('fr-FR', { day: 'numeric', month: 'long', year: 'numeric' });
    document.getElementById('plan-summary').innerHTML = `
        <h3>Résumé du plan</h3>
        <p><strong>Course cible:</strong> ${distance} km le ${formattedEventDate}</p>
        <p><strong>Progression:</strong> De ${currentTime} à ${targetTime} pour 10 km</p>
        <p><strong>Durée:</strong> ${plan[plan.length - 1].week} semaines</p>
        <p><strong>Séances totales:</strong> ${plan.length}</p>
    `;
    
    // Afficher la section du plan généré
    document.getElementById('generated-plan-card').style.display = 'block';
    
    // Sauvegarder le plan généré temporairement
    userData.customPlan = plan;
}

// Valider le format de temps hh:mm:ss
function isValidTimeFormat(time) {
    return /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/.test(time);
}

// Convertir un temps hh:mm:ss en secondes
function timeToSeconds(time) {
    const parts = time.split(':').map(Number);
    return parts[0] * 3600 + parts[1] * 60 + parts[2];
}

// Sauvegarder le plan généré
document.getElementById('save-plan-btn').addEventListener('click', function() {
    if (!userData.customPlan) {
        alert("Aucun plan à sauvegarder");
        return;
    }
    
    // Mettre à jour le plan d'entraînement
    userData.trainingPlan = userData.customPlan;
    
    // Mettre à jour les autres données utilisateur
    userData.targetPace = secondsToPace(timeToSeconds(document.getElementById('plan-target-time').value) / 10);
    userData.currentPace = secondsToPace(timeToSeconds(document.getElementById('plan-current-time').value) / 10);
    userData.eventDate = document.getElementById('plan-event-date').value;
    
    // Mettre à jour les jours d'entraînement
    userData.trainingDays = [];
    const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
    days.forEach(day => {
        if (document.getElementById(`plan-${day}`).checked) {
            userData.trainingDays.push(day);
        }
    });
    
    // Sauvegarder dans le stockage local
    localStorage.setItem('runPacerUserData', JSON.stringify(userData));
    
    // Mettre à jour l'affichage
    updateProfileDisplay();
    updateTrainingPlanDisplay();
    
    // Retourner à la section plan
    sections.forEach(s => {
        document.getElementById(`nav-${s}`).classList.remove('active');
        document.getElementById(`${s}-section`).classList.remove('active');
    });
    
    document.getElementById('nav-plan').classList.add('active');
    document.getElementById('plan-section').classList.add('active');
    
    alert("Votre plan a été sauvegardé avec succès!");
});

// Gestion du formulaire de création de plan
document.getElementById('plan-form').addEventListener('submit', function(e) {
    e.preventDefault();
    generateCustomPlan();
});

// Initialiser la date minimale (aujourd'hui + 1 jour)
document.getElementById('plan-event-date').min = new Date(new Date().getTime() + 86400000).toISOString().split('T')[0];
        
        // Générer un plan d'entraînement jusqu'à la date de l'événement
        function generateTrainingPlan() {
            const eventDate = new Date(userData.eventDate);
            const today = new Date();
            const daysDiff = Math.floor((eventDate - today) / (1000 * 60 * 60 * 24));
            
            if (daysDiff <= 0) {
                userData.trainingPlan = [];
                return;
            }
            
            const currentPaceSeconds = paceToSeconds(userData.currentPace);
            const targetPaceSeconds = paceToSeconds(userData.targetPace);
            const progressPerWeek = (targetPaceSeconds - currentPaceSeconds) / (daysDiff / 7);
            
            const plan = [];
            const trainingDays = userData.trainingDays;
            
            // Générer les séances pour chaque semaine
            for (let i = 0; i < daysDiff; i++) {
                const date = new Date(today);
                date.setDate(today.getDate() + i);
                const dayName = date.toLocaleDateString('fr-FR', { weekday: 'long' }).toLowerCase();
                
                if (trainingDays.includes(dayName)) {
                    // Déterminer le type de séance en fonction du jour
                    let type, distance, pace;
                    
                    if (dayName === 'mardi' || dayName === 'jeudi') {
                        // Séance de qualité (intervalles ou tempo)
                        type = Math.random() > 0.5 ? 'interval' : 'tempo';
                    } else {
                        // Séance longue ou facile
                        type = Math.random() > 0.5 ? 'long' : 'easy';
                    }
                    
                    // Calculer la distance et le rythme en fonction de la progression
                    const weekNum = Math.floor(i / 7);
                    const currentWeekPace = currentPaceSeconds + (progressPerWeek * weekNum);
                    const runType = runTypes[type];
                    
                    distance = runType.distance;
                    pace = secondsToPace(currentWeekPace + (runType.paceOffset * 60));
                    
                    // Ajouter la séance au plan
                    plan.push({
                        date: date.toISOString().split('T')[0],
                        day: dayName,
                        type: type,
                        typeName: runType.name,
                        distance: distance,
                        pace: pace,
                        completed: false
                    });
                }
            }
            
            userData.trainingPlan = plan;
            updateTrainingPlanDisplay();
            saveTrainingPlan();
        }
        
        // Mettre à jour l'affichage du plan d'entraînement
        function updateTrainingPlanDisplay() {
    const tbody = document.getElementById('full-plan-body');
    tbody.innerHTML = '';
    
    userData.trainingPlan.forEach((session, index) => {
        const tr = document.createElement('tr');
        tr.style.cursor = 'pointer';
        tr.addEventListener('click', () => startSelectedSession(index));
        
        const date = new Date(session.date);
        const formattedDate = date.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' });
        
        tr.innerHTML = `
            <td>${formattedDate} (${session.day.charAt(0).toUpperCase() + session.day.slice(1)})</td>
            <td>${session.typeName}</td>
            <td>${session.distance} km</td>
            <td>${session.pace} min/km</td>
            <td>${session.completed ? '<i class="fas fa-check" style="color: #2ecc71;"></i>' : '<i class="fas fa-times" style="color: #e74c3c;"></i>'}</td>
        `;
        
        tbody.appendChild(tr);
    });
    
    updateNextSession();
}


        function startSelectedSession(sessionIndex) {
    const session = userData.trainingPlan[sessionIndex];

    // Retirer la sélection précédente
    document.querySelectorAll('#full-plan-table tr').forEach(tr => {
        tr.classList.remove('selected-session');
    });
    
    // Ajouter la sélection à la ligne cliquée
    const allRows = document.querySelectorAll('#full-plan-table tr');
    if (allRows.length > sessionIndex + 1) { // +1 pour l'en-tête
        allRows[sessionIndex + 1].classList.add('selected-session');
    }
                
    // Désactiver toutes les sections
    sections.forEach(s => {
        document.getElementById(`nav-${s}`).classList.remove('active');
        document.getElementById(`${s}-section`).classList.remove('active');
    });
    
    // Activer la section "Courir"
    document.getElementById('nav-run').classList.add('active');
    document.getElementById('run-section').classList.add('active');
    
    // Définir le type de course sélectionné
    currentRunType = session.type;
    document.getElementById(`${session.type}-run`).checked = true;
    
    // Mettre à jour l'affichage du rythme cible
    document.getElementById('target-pace').textContent = session.pace;
    
    // Démarrer la course
    startRun();
}
        
        // Mettre à jour l'affichage de la prochaine séance
        function updateNextSession() {
            const nextSession = userData.trainingPlan.find(session => !session.completed);
            
            if (nextSession) {
                const date = new Date(nextSession.date);
                const formattedDate = date.toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' });
                
                document.getElementById('next-session-title').textContent = `${formattedDate.charAt(0).toUpperCase() + formattedDate.slice(1)} - ${nextSession.typeName}`;
                document.getElementById('next-session-distance').textContent = `${nextSession.distance} km`;
                document.getElementById('next-session-pace').textContent = `${nextSession.pace} min/km`;
                document.getElementById('next-session-goal').textContent = runTypes[nextSession.type].description;
                
                // Mettre à jour le type de course par défaut
                currentRunType = nextSession.type;
                document.getElementById(`${nextSession.type}-run`).checked = true;
            } else {
                document.getElementById('next-session-title').textContent = "Aucune séance programmée";
                document.getElementById('next-session-distance').textContent = "-- km";
                document.getElementById('next-session-pace').textContent = "--:-- min/km";
                document.getElementById('next-session-goal').textContent = "Votre plan d'entraînement est terminé!";
            }
        }
        
        // Mettre à jour les statistiques affichées
        function updateStats() {
            if (userData.runs.length === 0) return;
            
            // Calculer les totaux
            const totalRuns = userData.runs.length;
            const totalDistance = userData.runs.reduce((sum, run) => sum + parseFloat(run.distance), 0).toFixed(1);
            
            // Calculer les meilleurs rythmes
            const paces = userData.runs.map(run => paceToSeconds(run.pace));
            const bestPace = secondsToPace(Math.min(...paces));
            const avgPace = secondsToPace(paces.reduce((sum, pace) => sum + pace, 0) / paces.length);
            
            // Mettre à jour l'affichage
            document.getElementById('total-runs').textContent = totalRuns;
            document.getElementById('total-distance').textContent = totalDistance;
            document.getElementById('best-pace').textContent = bestPace;
            document.getElementById('avg-pace').textContent = avgPace;
            
            // Mettre à jour le graphique
            updatePaceChart();
        }
        
        // Mettre à jour le graphique de progression du rythme
        function updatePaceChart() {
            const ctx = document.getElementById('pace-chart').getContext('2d');
            
            // Trier les courses par date
            const sortedRuns = [...userData.runs].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Préparer les données
            const labels = sortedRuns.map(run => new Date(run.date).toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' }));
            const paces = sortedRuns.map(run => {
                const [mins, secs] = run.pace.split(':').map(Number);
                return mins + secs / 60;
            });
            
            // Créer ou mettre à jour le graphique
            if (window.paceChart) {
                window.paceChart.data.labels = labels;
                window.paceChart.data.datasets[0].data = paces;
                window.paceChart.update();
            } else {
                window.paceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Rythme (min/km)',
                            data: paces,
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            tension: 0.3,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                beginAtZero: false,
                                reverse: true,
                                title: {
                                    display: true,
                                    text: 'Rythme (min/km)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Date'
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Mettre à jour l'historique des courses
        function updateHistory() {
            const tbody = document.getElementById('history-table');
            tbody.innerHTML = '';
            
            userData.runs.forEach((run, index) => {
                const tr = document.createElement('tr');
                const date = new Date(run.date);
                const formattedDate = date.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short', year: 'numeric' });
                
                tr.innerHTML = `
                    <td>${formattedDate}</td>
                    <td>${runTypes[run.type]?.name || run.type}</td>
                    <td>${run.distance} km</td>
                    <td>${run.pace} min/km</td>
                    <td>
                        <button class="btn" onclick="showRunDetails(${index})"><i class="fas fa-eye"></i> Voir</button>
                    </td>
                `;
                
                tbody.appendChild(tr);
            });
            
            // Mettre à jour les statistiques
            updateStats();
        }
        
        // Afficher les détails d'une course
        function showRunDetails(runIndex) {
            const run = userData.runs[runIndex];
            if (!run) return;
            
            // Masquer toutes les sections
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Afficher la section de détail
            document.getElementById('run-detail-section').classList.add('active');
            
            // Mettre à jour les informations de la course
            document.getElementById('run-date').textContent = new Date(run.date).toLocaleDateString('fr-FR', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
            
            document.getElementById('run-detail-distance').textContent = run.distance;
            document.getElementById('run-detail-duration').textContent = formatTime(run.duration);
            document.getElementById('run-detail-pace').textContent = run.pace;
            
            // Afficher l'image du tracé si disponible
            if (run.routeImage) {
                document.getElementById('route-image').src = run.routeImage;
                document.getElementById('route-image').style.display = 'block';
            } else {
                document.getElementById('route-image').style.display = 'none';
            }
            
            // Calculer l'élévation si disponible
            let totalElevation = 0;
            if (run.gpsData && run.gpsData.length > 0) {
                for (let i = 1; i < run.gpsData.length; i++) {
                    if (run.gpsData[i].altitude && run.gpsData[i-1].altitude) {
                        const diff = run.gpsData[i].altitude - run.gpsData[i-1].altitude;
                        if (diff > 0) totalElevation += diff;
                    }
                }
            }
            document.getElementById('run-detail-elevation').textContent = Math.round(totalElevation);
            
            // Calculer le meilleur kilomètre si les données sont disponibles
            let bestPace = "N/A";
            if (run.splits && run.splits.length > 0) {
                const splitsPace = run.splits.map(split => paceToSeconds(split.pace));
                bestPace = secondsToPace(Math.min(...splitsPace));
            }
            document.getElementById('run-detail-best-pace').textContent = bestPace;
            
            // Afficher les splits
            const splitsTbody = document.getElementById('run-splits');
            splitsTbody.innerHTML = '';
            
            if (run.splits && run.splits.length > 0) {
                run.splits.forEach((split, index) => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `
                        <td>${index + 1}</td>
                        <td>${formatTime(split.duration)}</td>
                        <td>${split.pace} min/km</td>
                    `;
                    splitsTbody.appendChild(tr);
                });
            } else {
                splitsTbody.innerHTML = '<tr><td colspan="3">Aucun détail par kilomètre disponible</td></tr>';
            }
            
            // Configurer les boutons
            document.getElementById('share-run-btn').onclick = () => shareRun(run);
            document.getElementById('export-gpx-btn').onclick = () => exportToGPX(run);
            document.getElementById('strava-upload-btn').onclick = () => publishToStrava(run);
            document.getElementById('back-to-stats-btn').onclick = () => {
                document.getElementById('run-detail-section').classList.remove('active');
                document.getElementById('nav-stats').classList.add('active');
                document.getElementById('stats-section').classList.add('active');
            };
        }
        
        // Capturer une image de la carte
        async function captureRouteImage() {
            if (!mapObject || typeof html2canvas === 'undefined') return null;
            
            try {
                // Créer un conteneur temporaire pour la capture
                const tempContainer = document.createElement('div');
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-9999px';
                tempContainer.style.width = '300px';
                tempContainer.style.height = '200px';
                document.body.appendChild(tempContainer);
                
                // Créer une carte temporaire
                const tempMap = L.map(tempContainer).setView(mapObject.getCenter(), mapObject.getZoom());
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(tempMap);
                
                // Ajouter le tracé
                if (locationData.length > 1) {
                    const points = locationData.map(loc => [loc.latitude, loc.longitude]);
                    L.polyline(points, {color: '#3498db', weight: 3}).addTo(tempMap);
                    
                    // Ajouter des marqueurs de début et fin
                    L.circleMarker(points[0], {
                        color: '#2ecc71',
                        fillColor: '#2ecc71',
                        fillOpacity: 1,
                        radius: 5
                    }).addTo(tempMap).bindPopup("Départ");
                    
                    L.circleMarker(points[points.length - 1], {
                        color: '#e74c3c',
                        fillColor: '#e74c3c',
                        fillOpacity: 1,
                        radius: 5
                    }).addTo(tempMap).bindPopup("Arrivée");
                    
                    // Ajuster la vue
                    tempMap.fitBounds(L.polyline(points).getBounds());
                }
                
                // Attendre que la carte se charge
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Capturer l'image
                const canvas = await html2canvas(tempContainer, {
                    backgroundColor: null,
                    scale: 1,
                    logging: false,
                    useCORS: true
                });
                
                // Nettoyer
                tempMap.remove();
                document.body.removeChild(tempContainer);
                
                return canvas.toDataURL('image/png');
            } catch (error) {
                console.error('Erreur lors de la capture de la carte:', error);
                return null;
            }
        }
        
        // Fermer le modal
        document.querySelector('.close-modal').addEventListener('click', function() {
            document.getElementById('run-details-modal').style.display = 'none';
            
            // Supprimer la carte pour éviter les conflits
            if (runMapObject) {
                runMapObject.remove();
                runMapObject = null;
            }
        });
        
        // Navigation entre les sections
        const sections = ['plan', 'run', 'stats', 'profile', 'create-plan'];
        
        sections.forEach(section => {
            document.getElementById(`nav-${section}`).addEventListener('click', () => {
                // Désactiver tous les boutons et sections
                sections.forEach(s => {
                    document.getElementById(`nav-${s}`).classList.remove('active');
                    document.getElementById(`${s}-section`).classList.remove('active');
                });
                
                // Activer le bouton et la section cliqués
                document.getElementById(`nav-${section}`).classList.add('active');
                document.getElementById(`${section}-section`).classList.add('active');
            });
        });
        
        // Gestion du formulaire de profil
        document.getElementById('profile-form').addEventListener('submit', function(e) {
            e.preventDefault();
            
            // Mettre à jour les données utilisateur
            userData.currentPace = document.getElementById('current-pace-input').value;
            userData.targetPace = document.getElementById('target-pace-input').value;
            userData.eventDate = document.getElementById('event-date-input').value;
            userData.stravaToken = document.getElementById('strava-token-input').value;
            
            // Mettre à jour les jours d'entraînement
            userData.trainingDays = [];
            const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
            days.forEach(day => {
                if (document.getElementById(day).checked) {
                    userData.trainingDays.push(day);
                }
            });
            
            // Mettre à jour les instructions vocales
            userData.voiceEnabled = document.getElementById('voice-enabled').checked;
            
            // Sauvegarder dans le stockage local
            localStorage.setItem('runPacerUserData', JSON.stringify(userData));
            
            // Mettre à jour l'affichage
            updateProfileDisplay();
            generateTrainingPlan();
            
            // Afficher un message de confirmation
            alert('Vos modifications ont été enregistrées!');
        });
        
        // Mettre à jour l'affichage du profil
        function updateProfileDisplay() {
            document.getElementById('header-objective').textContent = `Atteignez votre objectif de ${userData.targetPace} min/km`;
            
            const eventDate = new Date(userData.eventDate);
            const formattedDate = eventDate.toLocaleDateString('fr-FR', { day: 'numeric', month: 'long', year: 'numeric' });
            
            document.getElementById('goal-event').innerHTML = `Course 10km: <strong>${formattedDate}</strong>`;
            document.getElementById('goal-pace').innerHTML = `Objectif rythme: <strong>${userData.targetPace} min/km</strong>`;
            document.getElementById('current-level').innerHTML = `Niveau actuel: <strong>${userData.currentPace} min/km</strong>`;
            
            // Formater les jours d'entraînement
            const dayNames = {
                monday: 'Lundi',
                tuesday: 'Mardi',
                wednesday: 'Mercredi',
                thursday: 'Jeudi',
                friday: 'Vendredi',
                saturday: 'Samedi',
                sunday: 'Dimanche'
            };
            
            const trainingDaysStr = userData.trainingDays.map(day => dayNames[day]).join(', ');
            document.getElementById('training-days').innerHTML = `Jours d'entraînement: <strong>${trainingDaysStr}</strong>`;
        }
        
        // Lien entre le bouton "Commencer la séance" et la section "Courir"
        document.getElementById('start-run-btn').addEventListener('click', () => {
            // Désactiver tous les boutons et sections
            sections.forEach(s => {
                document.getElementById(`nav-${s}`).classList.remove('active');
                document.getElementById(`${s}-section`).classList.remove('active');
            });
            
            // Activer la section "Courir"
            document.getElementById('nav-run').classList.add('active');
            document.getElementById('run-section').classList.add('active');
            
            // Définir le rythme cible en fonction du type de course
            const runType = runTypes[currentRunType];
            const currentPaceSeconds = paceToSeconds(userData.currentPace);
            const targetPaceSeconds = currentPaceSeconds + (runType.paceOffset * 60);
            
            document.getElementById('target-pace').textContent = secondsToPace(targetPaceSeconds);
            
            // Démarrer la simulation de course
            startRun();
        });
        
        // Gestion du changement de type de course
        document.querySelectorAll('input[name="run-type"]').forEach(radio => {
            radio.addEventListener('change', function() {
                if (this.checked) {
                    currentRunType = this.value;
                    const runType = runTypes[currentRunType];
                    
                    // Mettre à jour le rythme cible si la course n'a pas encore commencé
                    if (!isRunning) {
                        const currentPaceSeconds = paceToSeconds(userData.currentPace);
                        const targetPaceSeconds = currentPaceSeconds + (runType.paceOffset * 60);
                        document.getElementById('target-pace').textContent = secondsToPace(targetPaceSeconds);
                    }
                }
            });
        });
        
        // Initialiser la carte avec Leaflet
        function initializeMap() {
            // Vérifier si la carte est déjà initialisée
            if (mapObject) return;
            
            const mapElement = document.getElementById('map');
            
            // Si Leaflet est disponible, initialiser la carte
            if (typeof L !== 'undefined') {
                mapObject = L.map('map').setView([48.8566, 2.3522], 15); // Paris par défaut
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(mapObject);
                
                // Créer un layer pour le parcours
                window.routeLayer = L.layerGroup().addTo(mapObject);
            } else {
                // Fallback si Leaflet n'est pas disponible
                mapElement.innerHTML = '<div style="background-color: #e0e0e0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;"><i class="fas fa-map-marker-alt" style="font-size: 2rem; color: #3498db;"></i><span style="margin-left: 10px;">Carte non disponible</span></div>';
            }
        }
        
        // Demander les permissions de localisation
        function requestLocationPermission() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject("La géolocalisation n'est pas supportée par votre navigateur.");
                    return;
                }
                
                navigator.geolocation.getCurrentPosition(
                    position => resolve(position),
                    error => {
                        console.error('Erreur de géolocalisation:', error);
                        
                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                                reject('Vous avez refusé l\'accès à votre position.');
                                break;
                            case error.POSITION_UNAVAILABLE:
                                reject('Information de localisation non disponible.');
                                break;
                            case error.TIMEOUT:
                                reject('Délai d\'attente dépassé pour obtenir la position.');
                                break;
                            case error.UNKNOWN_ERROR:
                                reject('Une erreur inconnue s\'est produite.');
                                break;
                        }
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    }
                );
            });
        }
        
        <!-- calculateDistance défini dans utils.js -->
        
        // Mettre à jour la carte avec les nouvelles coordonnées
        function updateMap(latitude, longitude) {
            if (!mapObject || typeof L === 'undefined') return;
            
            // Centrer la carte sur la position actuelle
            mapObject.setView([latitude, longitude], 16);
            
            // Ajouter un point au parcours
            if (locationData.length > 1) {
                const lastLocation = locationData[locationData.length - 2];
                const routeLine = L.polyline(
                    [
                        [lastLocation.latitude, lastLocation.longitude],
                        [latitude, longitude]
                    ],
                    {color: 'blue', weight: 5}
                );
                window.routeLayer.addLayer(routeLine);
            }
            
            // Ajouter un marqueur à la position actuelle (et supprimer l'ancien s'il existe)
            if (window.currentPositionMarker) {
                mapObject.removeLayer(window.currentPositionMarker);
            }
            window.currentPositionMarker = L.circleMarker([latitude, longitude], {
                color: '#3498db',
                fillColor: '#3498db',
                fillOpacity: 1,
                radius: 8
            }).addTo(mapObject);
        }
        
        // Gestion des mises à jour de position GPS
        function handleLocationUpdate(position) {
            const { latitude, longitude, accuracy, speed, altitude } = position.coords;
            const timestamp = position.timestamp;
            
            // Ne garder que les points avec une précision suffisante (accuracy < 20 mètres)
            if (accuracy > 20) {
                console.log("Point GPS ignoré (précision insuffisante):", accuracy);
                return;
            }
            
            // Ajouter aux données de localisation avec plus d'infos
            locationData.push({ 
                latitude, 
                longitude, 
                accuracy, 
                speed, 
                altitude,
                timestamp 
            });
            
            // Calculer la distance si ce n'est pas le premier point
            if (previousLocation) {
                const segmentDistance = calculateDistance(
                    previousLocation.latitude, previousLocation.longitude,
                    latitude, longitude
                );
                
                // Filtrer les mauvaises lectures GPS (si la distance est trop grande en peu de temps)
                const timeElapsed = (timestamp - previousLocation.timestamp) / 1000; // en secondes
                const speedMps = segmentDistance / timeElapsed;
                
                // Ignorer les points aberrants (vitesse > 10 m/s ou 36 km/h)
                if (segmentDistance > 1 && speedMps < 10) {
        distanceTraveled += segmentDistance;
        
        // Gestion spécifique des intervalles
        if (runTypes[currentRunType].isInterval) {
            intervalDistanceRemaining -= segmentDistance;
            
            // Vérifier si on doit changer de phase
            if (intervalDistanceRemaining <= 0) {
                if (intervalPhase === 'work') {
                    intervalPhase = 'recovery';
                    intervalDistanceRemaining = runTypes[currentRunType].recoveryDuration;
                    currentTargetPace = secondsToPace(paceToSeconds(userData.currentPace) + 
                                       runTypes[currentRunType].recoveryPaceOffset * 60);
                    
                    // Annonce vocale
                    if (userData.voiceEnabled) {
                        const utterance = new SpeechSynthesisUtterance("Récupération");
                        utterance.lang = 'fr-FR';
                        speechSynthesis.speak(utterance);
                    }
                } else {
                    intervalPhase = 'work';
                    intervalDistanceRemaining = runTypes[currentRunType].intervalDuration;
                    currentTargetPace = secondsToPace(paceToSeconds(userData.currentPace) + 
                                       runTypes[currentRunType].paceOffset * 60);
                    
                    // Annonce vocale
                    if (userData.voiceEnabled) {
                        const utterance = new SpeechSynthesisUtterance("Intervalle rapide");
                        utterance.lang = 'fr-FR';
                        speechSynthesis.speak(utterance);
                    }
                }
            }

            // Ajouter ce code pour mettre à jour l'indicateur :
function updateIntervalIndicator() {
    if (runTypes[currentRunType].isInterval) {
        document.getElementById('interval-indicator').classList.remove('hidden');
        document.getElementById('interval-phase').textContent = 
            intervalPhase === 'work' ? 'Intervalle rapide' : 'Récupération';
        document.getElementById('interval-distance').textContent = 
            `Distance restante: ${Math.round(intervalDistanceRemaining)} m`;
    } else {
        document.getElementById('interval-indicator').classList.add('hidden');
    }
}
               // Mettre à jour l'affichage du rythme cible
            document.getElementById('target-pace').textContent = currentTargetPace;
        }
            
                    
                    // Vérifier si un nouveau kilomètre a été parcouru
                    const currentKm = Math.floor(distanceTraveled / 1000);
                    const previousKm = Math.floor((distanceTraveled - segmentDistance) / 1000);
                    
                    if (currentKm > previousKm) {
                        // Enregistrer le split du kilomètre
                        const kmDuration = currentDuration - currentKmStartTime;
                        const kmPace = secondsToPace(kmDuration / (1)); // 1 km
                        
                        kmSplits.push({
                            km: currentKm,
                            distance: 1, // 1 km
                            duration: kmDuration,
                            pace: kmPace
                        });
                        
                        currentKmStartTime = currentDuration;
                        currentKmStartDistance = distanceTraveled;
                        
                        // Instruction vocale pour le kilomètre parcouru
                        if (userData.voiceEnabled) {
                            const paceSpeech = paceToSpeech(kmPace);
                            const utterance = new SpeechSynthesisUtterance(`Kilomètre ${currentKm} en ${paceSpeech}`);
                            utterance.lang = 'fr-FR';
                            speechSynthesis.speak(utterance);
                            
                            // Afficher l'indicateur vocal
                            document.getElementById('voice-indicator').classList.remove('hidden');
                            setTimeout(() => {
                                document.getElementById('voice-indicator').classList.add('hidden');
                            }, 3000);
                        }
                    }
                    
                    // Mettre à jour l'affichage
                    document.getElementById('distance').textContent = (distanceTraveled / 1000).toFixed(2);
                    
                    // Calculer le rythme actuel en min/km
                    let currentPaceSeconds;
                    if (speed && speed > 0) {
                        // Utiliser la vitesse du GPS si disponible (en m/s)
                        currentPaceSeconds = (1000 / speed) / 60; // Convertir en min/km
                    } else {
                        // Calculer à partir de la distance et du temps
                        const currentSpeed = segmentDistance / timeElapsed; // m/s
                        if (currentSpeed > 0) {
                            currentPaceSeconds = (1000 / currentSpeed) / 60; // min/km
                        } else {
                            currentPaceSeconds = 0;
                        }
                    }
                    
                    // Mettre à jour l'affichage du rythme
                    if (currentPaceSeconds > 0) {
                        const paceMinutes = Math.floor(currentPaceSeconds);
                        const paceSeconds = Math.floor((currentPaceSeconds - paceMinutes) * 60);
                        document.getElementById('current-pace').textContent = 
                            `${paceMinutes}:${paceSeconds.toString().padStart(2, '0')}`;
                        
                        // Feedback sur le rythme
                        updatePaceFeedback(currentPaceSeconds * 60); // Convertir en secondes
                    }
                    
                    // Mettre à jour la carte
                    updateMap(latitude, longitude);
                }
            } else {
                // Premier point, initialiser la carte
                updateMap(latitude, longitude);
                currentKmStartTime = currentDuration;
                currentKmStartDistance = 0;
            }
            
            previousLocation = { latitude, longitude, timestamp };
        }
        
        // Démarrer le suivi GPS
        function startGpsTracking() {
            if (navigator.geolocation) {
                watchId = navigator.geolocation.watchPosition(
                    handleLocationUpdate,
                    error => {
                        console.error('Erreur de géolocalisation:', error);
                        alert(`Erreur GPS: ${error.message}`);
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    }
                );
                isTrackingLocation = true;
            } else {
                alert('La géolocalisation n\'est pas supportée par votre navigateur.');
            }
        }
        
        // Arrêter le suivi GPS
        function stopGpsTracking() {
            if (watchId !== undefined) {
                navigator.geolocation.clearWatch(watchId);
                watchId = undefined;
                isTrackingLocation = false;
            }
        }
        
        // Mettre à jour le feedback de rythme
        function updatePaceFeedback(currentPaceSeconds) {
    const targetPaceSeconds = paceToSeconds(currentTargetPace);
    const paceFeedback = document.getElementById('pace-feedback');
            
            if (currentPaceSeconds < targetPaceSeconds - 15) {
                paceFeedback.textContent = "Ralentissez un peu!";
                paceFeedback.className = "too-fast";
                
                // Instruction vocale si nécessaire
                if (userData.voiceEnabled && currentDuration - lastSpokenTime > 60) {
                    const utterance = new SpeechSynthesisUtterance("Ralentissez un peu, vous êtes trop puissant et rapide. Unlimited power.");
                    utterance.lang = 'fr-FR';
                    speechSynthesis.speak(utterance);
                    lastSpokenTime = currentDuration;
                    
                    // Afficher l'indicateur vocal
                    document.getElementById('voice-indicator').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('voice-indicator').classList.add('hidden');
                    }, 3000);
                }
            } else if (currentPaceSeconds > targetPaceSeconds + 15) {
                paceFeedback.textContent = "Accélérez un peu!";
                paceFeedback.className = "too-slow";
                
                // Instruction vocale si nécessaire
                if (userData.voiceEnabled && currentDuration - lastSpokenTime > 60) {
                    const utterance = new SpeechSynthesisUtterance("Accélérez feignasse, vous êtes trop lent.");
                    utterance.lang = 'fr-FR';
                    speechSynthesis.speak(utterance);
                    lastSpokenTime = currentDuration;
                    
                    // Afficher l'indicateur vocal
                    document.getElementById('voice-indicator').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('voice-indicator').classList.add('hidden');
                    }, 3000);
                }
            } else {
                paceFeedback.textContent = "Bon rythme, continuez!";
                paceFeedback.className = "good-pace";
            }
        }
        
        // Fonction pour démarrer la course
        async function startRun() {
    // Réinitialiser les variables
    isRunning = true;
    currentDuration = 0;
    distanceTraveled = 0;
    locationData = [];
    previousLocation = null;
    kmSplits = [];
    currentKmStartTime = 0;
    currentKmStartDistance = 0;
    currentRouteImage = null;

    // Utiliser le rythme cible de la session sélectionnée
    const targetPace = document.getElementById('target-pace').textContent;
    currentTargetPace = targetPace;

    // Initialiser les intervalles si nécessaire
    if (runTypes[currentRunType].isInterval) {
        intervalPhase = 'work';
        intervalDistanceRemaining = runTypes[currentRunType].intervalDuration;
        
        // Première annonce
        if (userData.voiceEnabled) {
            const utterance = new SpeechSynthesisUtterance("Début des intervalles. Premier intervalle rapide.");
            utterance.lang = 'fr-FR';
            speechSynthesis.speak(utterance);
        }
    }
    
    // Initialiser la carte
    initializeMap();
    
    // Nettoyer le parcours précédent sur la carte
    if (window.routeLayer) {
        window.routeLayer.clearLayers();
    }
    
    // Réinitialiser l'affichage
    document.getElementById('current-pace').textContent = "--:--";
    document.getElementById('distance').textContent = "0.00";
    document.getElementById('duration').textContent = "00:00";
    document.getElementById('pace-feedback').textContent = "Course en cours...";
    document.getElementById('pace-feedback').className = "good-pace";
    
    // Activer/désactiver les boutons
    document.getElementById('pause-btn').innerHTML = '<i class="fas fa-pause"></i> Pause';
    document.getElementById('pause-btn').onclick = pauseRun;
    document.getElementById('stop-btn').disabled = false;
    
    // Démarrer le chrono
    runInterval = setInterval(updateRunningTime, 1000);
    
    // Démarrer le GPS
    startGpsTracking();
    
    // Instruction vocale
    if (userData.voiceEnabled) {
        const runType = runTypes[currentRunType];
        const targetPaceSpeech = paceToSpeech(document.getElementById('target-pace').textContent);
        const utterance = new SpeechSynthesisUtterance(`Début de la ${runType.name.toLowerCase()}. Objectif: ${targetPaceSpeech} par kilomètre.`);
        utterance.lang = 'fr-FR';
        speechSynthesis.speak(utterance);
        
        // Afficher l'indicateur vocal
        document.getElementById('voice-indicator').classList.remove('hidden');
        setTimeout(() => {
            document.getElementById('voice-indicator').classList.add('hidden');
        }, 3000);
    }

    // Enregistrer le Service Worker pour le suivi en arrière-plan
    if ('serviceWorker' in navigator) {
        try {
            const registration = await navigator.serviceWorker.ready;
            
            // Stocker les données de course pour l'arrière-plan
            const runData = {
                startTime: new Date().getTime(),
                runType: currentRunType,
                targetPace: currentTargetPace,
                locations: []
            };
            
            if (navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({
                    type: 'SET_BACKGROUND_RUN',
                    runData: runData
                });
            }

            // Enregistrer la synchronisation si l'API est disponible
            if ('SyncManager' in window) {
                try {
                    await registration.sync.register('sync-run-data');
                    console.log('Sync registered for background tracking');
                } catch (e) {
                    console.log('Sync registration failed:', e);
                }
            }
        } catch (error) {
            console.error('Service Worker error:', error);
        }
    }

    // Démarrer le suivi en arrière-plan si l'application est fermée
    if ('wakeLock' in navigator) {
        try {
            const wakeLock = await navigator.wakeLock.request('screen');
            wakeLock.addEventListener('release', () => {
                console.log('Wake Lock was released');
            });
            console.log('Wake Lock is active');
        } catch (err) {
            console.error('Wake Lock error:', err);
        }
    }
}

        // Stocker les données de course périodiquement
function storeRunDataPeriodically() {
    if (!isRunning) return;
    
    const runData = {
        startTime: new Date().getTime() - (currentDuration * 1000),
        currentDuration: currentDuration,
        distanceTraveled: distanceTraveled,
        locations: locationData,
        kmSplits: kmSplits,
        runType: currentRunType,
        targetPace: currentTargetPace
    };
    
    localStorage.setItem('currentRunData', JSON.stringify(runData));
    
    // Envoyer au Service Worker
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({
            type: 'UPDATE_BACKGROUND_RUN',
            runData: runData
        });
    }
    
    setTimeout(storeRunDataPeriodically, 10000); // Toutes les 10 secondes
}

// Récupérer les données de course interrompue
function recoverInterruptedRun() {
    const savedRun = localStorage.getItem('currentRunData');
    if (savedRun) {
        const runData = JSON.parse(savedRun);
        
        // Vérifier si la course était en cours (moins de 1h depuis le dernier enregistrement)
        const timeSinceLastUpdate = new Date().getTime() - (runData.startTime + (runData.currentDuration * 1000));
        if (timeSinceLastUpdate < 3600000) { // 1 heure
            const shouldResume = confirm("Une course en cours a été détectée. Voulez-vous reprendre ?");
            if (shouldResume) {
                // Restaurer les données
                currentDuration = runData.currentDuration;
                distanceTraveled = runData.distanceTraveled;
                locationData = runData.locations || [];
                kmSplits = runData.kmSplits || [];
                currentRunType = runData.runType || 'easy';
                currentTargetPace = runData.targetPace || userData.targetPace;
                
                // Redémarrer la course
                startRun();
                
                // Mettre à jour l'affichage
                document.getElementById('distance').textContent = (distanceTraveled / 1000).toFixed(2);
                document.getElementById('duration').textContent = formatTime(currentDuration);
                
                // Restaurer la carte si possible
                if (locationData.length > 0 && mapObject) {
                    updateMap(locationData[locationData.length-1].latitude, 
                             locationData[locationData.length-1].longitude);
                    
                    // Redessiner le parcours
                    if (window.routeLayer) {
                        window.routeLayer.clearLayers();
                        const points = locationData.map(loc => [loc.latitude, loc.longitude]);
                        L.polyline(points, {color: 'blue', weight: 5}).addTo(window.routeLayer);
                    }
                }
                
                return true;
            }
        }
        
        // Nettoyer si l'utilisateur ne veut pas reprendre
        localStorage.removeItem('currentRunData');
    }
    return false;
}

// Gérer la reprise après arrière-plan
function handleAppResume() {
  if (isBackgroundRun) {
    // Récupérer les données du Service Worker
    if (navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage({
        type: 'GET_BACKGROUND_RUN'
      });
    }
    
    // Redémarrer le suivi
    isBackgroundRun = false;
    startRun();
  }
}

// Écouter les messages du Service Worker
navigator.serviceWorker.addEventListener('message', event => {
  if (event.data.type === 'BACKGROUND_RUN_DATA') {
    const runData = event.data.runData;
    // Traiter les données récupérées de l'arrière-plan
    console.log('Données récupérées:', runData);
    
    // Mettre à jour l'interface avec les données
    if (runData.locations.length > 0) {
      locationData = runData.locations;
      distanceTraveled = calculateTotalDistance(runData.locations);
      currentDuration = Math.floor((new Date().getTime() - runData.startTime) / 1000);
      
      // Mettre à jour l'affichage
      document.getElementById('distance').textContent = (distanceTraveled / 1000).toFixed(2);
      document.getElementById('duration').textContent = formatTime(currentDuration);
      
      // Recalculer le rythme
      if (distanceTraveled > 0 && currentDuration > 0) {
        const paceSeconds = (currentDuration / (distanceTraveled / 1000));
        const avgPace = secondsToPace(paceSeconds);
        document.getElementById('current-pace').textContent = avgPace;
      }
    }
  }
});

// Calculer la distance totale à partir des points GPS
function calculateTotalDistance(locations) {
  let total = 0;
  for (let i = 1; i < locations.length; i++) {
    total += calculateDistance(
      locations[i-1].latitude, locations[i-1].longitude,
      locations[i].latitude, locations[i].longitude
    );
  }
  return total;
}

// Écouter les événements de visibilité de la page
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'hidden') {
    // L'application passe en arrière-plan
    if (isRunning) {
      isBackgroundRun = true;
      console.log('Application en arrière-plan, suivi continu');
    }
  } else {
    // L'application revient au premier plan
    handleAppResume();
  }
});

// Sauvegarder automatiquement le plan d'entraînement
function saveTrainingPlan() {
  localStorage.setItem('runPacerTrainingPlan', JSON.stringify(userData.trainingPlan));
}

// Charger le plan d'entraînement au démarrage
function loadTrainingPlan() {
  const savedPlan = localStorage.getItem('runPacerTrainingPlan');
  if (savedPlan) {
    userData.trainingPlan = JSON.parse(savedPlan);
    updateTrainingPlanDisplay();
  }
}

// Appeler loadTrainingPlan au démarrage sera géré plus loin
        
        
        
        // Mettre à jour uniquement le temps qui s'écoule
        function updateRunningTime() {
            currentDuration++;
            document.getElementById('duration').textContent = formatTime(currentDuration);
            
            // Annoncer la distance tous les kilomètres (fallback si GPS non disponible)
            if (distanceTraveled === 0) {
                const simulatedDistance = currentDuration / 300 * 1000; // Simuler 5:00 min/km
                const currentKm = Math.floor(simulatedDistance / 1000);
                
                if (currentKm > 0 && currentKm > Math.floor((simulatedDistance - 100) / 1000)) {
                    if (userData.voiceEnabled) {
                        const pace = secondsToPace(currentDuration / currentKm);
                        const paceSpeech = paceToSpeech(pace);
                        const utterance = new SpeechSynthesisUtterance(`Kilomètre ${currentKm} simulé en ${paceSpeech}`);
                        utterance.lang = 'fr-FR';
                        speechSynthesis.speak(utterance);
                        
                        // Afficher l'indicateur vocal
                        document.getElementById('voice-indicator').classList.remove('hidden');
                        setTimeout(() => {
                            document.getElementById('voice-indicator').classList.add('hidden');
                        }, 3000);
                    }
                }
            }
        }
        
        // Fonction pour mettre en pause la course
        function pauseRun() {
    isRunning = false;
    clearInterval(runInterval);
    stopGpsTracking();
    
    // Mettre à jour l'affichage des boutons
    document.getElementById('pause-btn').innerHTML = '<i class="fas fa-play"></i> Reprendre';
    document.getElementById('pause-btn').onclick = resumeRun;
    document.getElementById('pace-feedback').textContent = "Course en pause";
    
    // Sauvegarder l'état actuel
    storeRunDataPeriodically();
    
    // Instruction vocale
    if (userData.voiceEnabled) {
        const utterance = new SpeechSynthesisUtterance("Course en pause");
        utterance.lang = 'fr-FR';
        speechSynthesis.speak(utterance);
    }
}

        
        // Fonction pour reprendre la course
        function resumeRun() {
            isRunning = true;
            runInterval = setInterval(updateRunningTime, 1000);
            startGpsTracking();
            
            // Mettre à jour l'affichage des boutons
            document.getElementById('pause-btn').innerHTML = '<i class="fas fa-pause"></i> Pause';
            document.getElementById('pause-btn').onclick = pauseRun;
            document.getElementById('pace-feedback').textContent = "Course en cours...";
            
            // Instruction vocale
            if (userData.voiceEnabled) {
                const utterance = new SpeechSynthesisUtterance("Reprise de la course");
                utterance.lang = 'fr-FR';
                speechSynthesis.speak(utterance);
                
                // Afficher l'indicateur vocal
                document.getElementById('voice-indicator').classList.remove('hidden');
                setTimeout(() => {
                    document.getElementById('voice-indicator').classList.add('hidden');
                }, 3000);
            }
        }
        
        // Fonction pour arrêter la course
        document.getElementById('stop-btn').addEventListener('click', async function() {
            if (isRunning || document.getElementById('pause-btn').innerHTML.includes('Reprendre')) {
                clearInterval(runInterval);
                stopGpsTracking();
                
                // Calculer le rythme moyen
                let avgPace = "--:--";
                if (distanceTraveled > 0 && currentDuration > 0) {
                    const paceSeconds = (currentDuration / (distanceTraveled / 1000));
                    avgPace = secondsToPace(paceSeconds);
                } else if (currentDuration > 0) {
                    // Fallback si pas de GPS: utiliser un rythme simulé
                    avgPace = document.getElementById('target-pace').textContent;
                }
                
                // Instruction vocale
                if (userData.voiceEnabled) {
                    const paceSpeech = paceToSpeech(avgPace);
                    const utterance = new SpeechSynthesisUtterance(`Fin de la course. Rythme moyen: ${paceSpeech} par kilomètre.`);
                    utterance.lang = 'fr-FR';
                    speechSynthesis.speak(utterance);
                    
                    // Afficher l'indicateur vocal
                    document.getElementById('voice-indicator').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('voice-indicator').classList.add('hidden');
                    }, 3000);
                }
                
                // Capturer une image du tracé si des données GPS sont disponibles
                let routeImage = null;
                if (locationData.length > 1) {
                    routeImage = await captureRouteImage();
                }
                
                // Sauvegarder la course seulement si une distance a été parcourue
                if (distanceTraveled > 0 || currentDuration > 60) {
                    const newRun = {
                        date: new Date().toISOString().split('T')[0],
                        type: currentRunType,
                        typeName: runTypes[currentRunType].name,
                        distance: (distanceTraveled > 0 ? (distanceTraveled / 1000) : (currentDuration / paceToSeconds(avgPace))).toFixed(2),
                        pace: avgPace,
                        duration: currentDuration,
                        gpsData: locationData,
                        splits: kmSplits,
                        routeImage: routeImage
                    };
                    
                    userData.runs.unshift(newRun); // Ajouter au début de l'historique
                    
                    // Marquer la séance comme terminée dans le plan d'entraînement
                    const today = new Date().toISOString().split('T')[0];
                    const sessionIndex = userData.trainingPlan.findIndex(session => session.date === today && session.type === currentRunType);
                    
                    if (sessionIndex !== -1) {
                        userData.trainingPlan[sessionIndex].completed = true;
                    }
                    
                    // Sauvegarder dans le stockage local
                    localStorage.setItem('runPacerUserData', JSON.stringify(userData));
                    
                    // Mise à jour des statistiques
                    updateHistory();
                    updateTrainingPlanDisplay();
                }
                
                // Redirection vers la section des statistiques
                sections.forEach(s => {
                    document.getElementById(`nav-${s}`).classList.remove('active');
                    document.getElementById(`${s}-section`).classList.remove('active');
                });
                
                document.getElementById('nav-stats').classList.add('active');
                document.getElementById('stats-section').classList.add('active');
                
                // Réinitialiser l'interface de course
                isRunning = false;
                document.getElementById('current-pace').textContent = "--:--";
                document.getElementById('distance').textContent = "0.00";
                document.getElementById('duration').textContent = "00:00";
                document.getElementById('pause-btn').innerHTML = '<i class="fas fa-play"></i> Démarrer';
                document.getElementById('pause-btn').onclick = startRun;
                document.getElementById('stop-btn').disabled = true;
                document.getElementById('pace-feedback').textContent = "Prêt à commencer";
            }
        });
        
        // Charger les données utilisateur depuis le stockage local au démarrage
        window.addEventListener('DOMContentLoaded', function() {
    // Charger les données utilisateur
    const savedData = localStorage.getItem('runPacerUserData');
    if (savedData) {
        const parsedData = JSON.parse(savedData);
        Object.assign(userData, parsedData);
        
        // Mettre à jour le formulaire avec les données sauvegardées
        document.getElementById('current-pace-input').value = userData.currentPace;
        document.getElementById('target-pace-input').value = userData.targetPace;
        document.getElementById('event-date-input').value = userData.eventDate;
        document.getElementById('strava-token-input').value = userData.stravaToken || '';
        
        // Jours d'entraînement
        const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
        days.forEach(day => {
            document.getElementById(day).checked = userData.trainingDays.includes(day);
        });
        
        // Instructions vocales
        document.getElementById('voice-enabled').checked = userData.voiceEnabled;
        
        // Mettre à jour l'affichage
        updateProfileDisplay();
    }
    
    // Charger le plan d'entraînement
    loadTrainingPlan();
    
    // Vérifier s'il y a une course à récupérer
    if (!recoverInterruptedRun()) {
        // Générer un plan d'entraînement par défaut si aucun n'existe
        if (userData.trainingPlan.length === 0) {
            generateTrainingPlan();
        }
    }
    
    // Vérifier la disponibilité de la synthèse vocale
    if ('speechSynthesis' in window) {
        console.log("Synthèse vocale disponible");
    } else {
        console.log("Synthèse vocale non disponible");
        userData.voiceEnabled = false;
        document.getElementById('voice-enabled').checked = false;
        document.getElementById('voice-enabled').disabled = true;
    }
    
    // Initialiser une carte simple (placeholder)
    const mapElement = document.getElementById('map');
    mapElement.innerHTML = '<div style="background-color: #e0e0e0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;"><i class="fas fa-map-marker-alt" style="font-size: 2rem; color: #3498db;"></i><span style="margin-left: 10px;">Carte de suivi GPS</span></div>';
    
    // Définir le bouton pause/démarrer
    document.getElementById('pause-btn').onclick = startRun;
    
    // Démarrer le stockage périodique des données
    setTimeout(storeRunDataPeriodically, 10000);
});

        // Service Worker pour la fonctionnalité PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('service-worker.js')
                    .then(function(registration) {
                        console.log('ServiceWorker enregistré avec succès:', registration.scope);
                    })
                    .catch(function(error) {
                        console.log('Échec de l\'enregistrement du ServiceWorker:', error);
                    });
            });
        }
        
        // Vérifier la disponibilité du GPS
        if ('geolocation' in navigator) {
            console.log("Géolocalisation disponible");
        } else {
            console.log("Géolocalisation non disponible");
            alert("Votre appareil ne prend pas en charge la géolocalisation. Certaines fonctionnalités ne seront pas disponibles.");
        }

        function generateGPX(run) {
            if (!run.gpsData || run.gpsData.length < 2) return null;

            let gpxContent = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="RunPacer App" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>RunPacer - Course du ${run.date}</name>
    <time>${new Date(run.date).toISOString()}</time>
  </metadata>
  <trk>
    <name>Course ${run.type} - ${run.distance}km</name>
    <trkseg>`;

            run.gpsData.forEach(point => {
                gpxContent += `
      <trkpt lat="${point.latitude}" lon="${point.longitude}">
        <ele>${point.altitude || 0}</ele>
        <time>${new Date(point.timestamp).toISOString()}</time>
      </trkpt>`;
            });

            gpxContent += `
    </trkseg>
  </trk>
</gpx>`;

            return gpxContent;
        }

        // Exporter la course au format GPX
        function exportToGPX(run) {
            const gpxContent = generateGPX(run);
            if (!gpxContent) {
                alert("Pas de données GPS disponibles pour cette course");
                return;
            }
            
            // Créer un Blob et un lien de téléchargement
            const blob = new Blob([gpxContent], { type: 'application/gpx+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `runpacer-${run.date}-${run.distance}km.gpx`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Partager la course
        function shareRun(run) {
            if (navigator.share) {
                // Utiliser Web Share API si disponible
                navigator.share({
                    title: `Ma course RunPacer - ${run.distance}km`,
                    text: `J'ai couru ${run.distance}km en ${formatTime(run.duration)} (rythme: ${run.pace}/km) avec RunPacer!`,
                    // url: window.location.href  // On pourrait ajouter une URL si l'app est hébergée
                })
                .catch(error => {
                    console.log('Erreur lors du partage:', error);
                    alert("Impossible de partager: " + error.message);
                });
            } else {
                // Fallback si Web Share API n'est pas disponible
                const shareText = `J'ai couru ${run.distance}km en ${formatTime(run.duration)} (rythme: ${run.pace}/km) avec RunPacer!`;
                alert("Fonction de partage non disponible. Voici le texte à partager:\n\n" + shareText);
            }
        }

        async function publishToStrava(run) {
            const token = userData.stravaToken;
            if (!token) {
                alert("Ajoutez votre token Strava dans le profil");
                return;
            }

            try {
                if (run.gpsData && run.gpsData.length >= 2) {
                    const gpxContent = generateGPX(run);
                    const formData = new FormData();
                    formData.append('file', new Blob([gpxContent], { type: 'application/gpx+xml' }), 'run.gpx');
                    formData.append('data_type', 'gpx');
                    formData.append('name', `RunPacer ${run.distance}km`);
                    formData.append('description', `Rythme ${run.pace}/km via RunPacer`);
                    formData.append('activity_type', 'run');

                    const resp = await fetch('https://www.strava.com/api/v3/uploads', {
                        method: 'POST',
                        headers: { 'Authorization': 'Bearer ' + token },
                        body: formData
                    });
                    const data = await resp.json();
                    if (!resp.ok) throw new Error(data.message || 'Erreur');
                    alert('Course envoyée sur Strava. Elle apparaîtra une fois traitée.');
                } else {
                    const params = new URLSearchParams();
                    params.append('name', `RunPacer ${run.distance}km`);
                    params.append('type', 'Run');
                    params.append('start_date_local', run.date + 'T00:00:00');
                    params.append('elapsed_time', Math.round(run.duration));
                    params.append('description', `Rythme ${run.pace}/km via RunPacer`);
                    params.append('distance', Math.round(parseFloat(run.distance) * 1000));
                    const resp = await fetch('https://www.strava.com/api/v3/activities', {
                        method: 'POST',
                        headers: {
                            'Authorization': 'Bearer ' + token,
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: params.toString()
                    });
                    const data = await resp.json();
                    if (!resp.ok) throw new Error(data.message || 'Erreur');
                    alert('Course ajoutée sur Strava.');
                }
            } catch (err) {
                alert('Erreur Strava: ' + err.message);
            }
        }
    </script>
</body>
</html>
